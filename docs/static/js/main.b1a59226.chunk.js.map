{"version":3,"sources":["assets/qpl_logo.svg","assets/home_uml.png","assets/ab_uml1.png","components/Nav/Nav.js","assets/deflate.js","components/Home/Home.js","components/About/About.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Nav","document","addEventListener","$navbarBurgers","Array","prototype","slice","call","querySelectorAll","length","forEach","el","target","dataset","$target","getElementById","classList","toggle","className","class","role","aria-label","src","logo","alt","aria-expanded","data-target","aria-hidden","id","to","href","zip_free_queue","zip_qhead","zip_qtail","zip_initflag","zip_outcnt","zip_outoff","zip_complete","zip_window","zip_d_buf","zip_l_buf","zip_prev","zip_bi_buf","zip_bi_valid","zip_block_start","zip_ins_h","zip_hash_head","zip_prev_match","zip_match_available","zip_match_length","zip_prev_length","zip_strstart","zip_match_start","zip_eofile","zip_lookahead","zip_max_chain_length","zip_max_lazy_match","zip_compr_level","zip_good_match","zip_dyn_ltree","zip_dyn_dtree","zip_static_ltree","zip_static_dtree","zip_bl_tree","zip_l_desc","zip_d_desc","zip_bl_desc","zip_bl_count","zip_heap","zip_heap_len","zip_heap_max","zip_depth","zip_length_code","zip_dist_code","zip_base_length","zip_base_dist","zip_flag_buf","zip_last_lit","zip_last_dist","zip_last_flags","zip_flags","zip_flag_bit","zip_opt_len","zip_static_len","zip_deflate_data","zip_deflate_pos","zip_H_SHIFT","parseInt","zip_outbuf","zip_extra_lbits","zip_extra_dbits","zip_extra_blbits","zip_bl_order","zip_configuration_table","zip_DeflateConfiguration","zip_DeflateCT","this","fc","dl","zip_DeflateTreeDesc","dyn_tree","static_tree","extra_bits","extra_base","elems","max_length","max_code","a","b","c","d","good_length","max_lazy","nice_length","max_chain","zip_DeflateBuffer","next","len","ptr","off","zip_reuse_queue","p","zip_head1","i","zip_head2","val","zip_put_byte","q","zip_new_queue","zip_qoutbuf","zip_put_short","w","zip_OUTBUFSIZ","zip_INSERT_STRING","zip_HASH_SIZE","zip_WSIZE","zip_SEND_CODE","tree","zip_send_bits","zip_D_CODE","dist","zip_SMALLER","n","m","zip_read_buff","buff","offset","charCodeAt","zip_longest_match","cur_match","matchp","chain_length","scanp","best_len","limit","strendp","scan_end1","scan_end","zip_fill_window","more","zip_init_deflate","bits","code","zip_LITERALS","zip_LENGTH_CODES","zip_gen_codes","zip_L_CODES","zip_bi_reverse","zip_init_block","zip_ct_init","j","zip_MAX_MATCH","zip_MIN_MATCH","zip_lm_init","zip_deflate_internal","buff_size","zip_qcopy","flush","zip_ct_tally","zip_flush_block","zip_deflate_fast","zip_deflate_better","zip_pqdownheap","k","v","next_code","zip_MAX_BITS","zip_build_tree","desc","stree","node","xnew","h","xbits","f","extra","base","overflow","zip_gen_bitlen","zip_scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","zip_send_tree","eof","opt_lenb","static_lenb","max_blindex","stored_len","zip_BL_CODES","zip_build_bl_tree","zip_bi_windup","zip_compress_block","lcodes","dcodes","blcodes","rank","zip_send_all_trees","lc","dcode","out_length","in_length","zip_LIT_BUFSIZE","ltree","dtree","lx","dx","fx","flag","value","res","codify","word","Promise","resolve","reject","data","r","append3bytes","encode64","str","level","out","zip_INBUFSIZ","zip_deflate_start","String","fromCharCode","zip_deflate","b1","b2","b3","c2","c3","c4","encode6bit","Home","defaultValue","spellCheck","onClick","e","text","querySelector","unescape","encodeURIComponent","sendBtn","add","then","setTimeout","remove","uml","About","icon","faHashtag","imgUml1","faAngleRight","App","basename","path","exact","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b1a59226.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/qpl_logo.d25874a3.svg\";","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport logo from '../../assets/qpl_logo.svg';\r\n\r\nconst Nav = () => {\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n        // Get all \"navbar-burger\" elements\r\n        const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);\r\n        // Check if there are any navbar burgers\r\n        if ($navbarBurgers.length > 0) {\r\n            // Add a click event on each of them\r\n            $navbarBurgers.forEach(el => {\r\n                el.addEventListener('click', () => {\r\n                    // Get the target from the \"data-target\" attribute\r\n                    const target = el.dataset.target;\r\n                    const $target = document.getElementById(target);\r\n                    // Toggle the \"is-active\" class on both the \"navbar-burger\" and the \"navbar-menu\"\r\n                    el.classList.toggle('is-active');\r\n                    $target.classList.toggle('is-active');\r\n\r\n                });\r\n            });\r\n        }\r\n\r\n    });\r\n\r\n    return (\r\n        <div className=\"container is-fluid\">\r\n            <nav class=\"navbar\" role=\"navigation\" aria-label=\"main navigation\">\r\n                <div class=\"navbar-brand\">\r\n                    <img src={logo} alt=\"logo\" className=\"main-logo\" />\r\n\r\n                    <a role=\"button\" class=\"navbar-burger burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"main-links\">\r\n                        <span aria-hidden=\"true\"></span>\r\n                        <span aria-hidden=\"true\"></span>\r\n                        <span aria-hidden=\"true\"></span>\r\n                    </a>\r\n                </div>\r\n\r\n                <div id=\"main-links\" class=\"navbar-menu\">\r\n                    <div class=\"navbar-end\">\r\n                        <div class=\"navbar-item\">\r\n                            <Link className=\"bold main\" to=\"/\">Home</Link>\r\n                        </div>\r\n                        <div class=\"navbar-item\">\r\n                            <Link className=\"bold main\" to=\"/about\">About</Link>\r\n                        </div>\r\n                        <div class=\"navbar-item\">\r\n                            <a className=\"bold main\" href=\"https://github.com/alexpierola/quickplantuml\">View on GitHub</a>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </nav>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Nav;\r\n","/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\r\n * Version: 1.0.1\r\n * LastModified: Dec 25 1999\r\n */\r\n\r\n/* Interface:\r\n * data = zip_deflate(src);\r\n */\r\n\r\n/* constant parameters */\r\nvar zip_WSIZE = 32768;\t\t// Sliding Window size\r\nvar zip_STORED_BLOCK = 0;\r\nvar zip_STATIC_TREES = 1;\r\nvar zip_DYN_TREES = 2;\r\n\r\n/* for deflate */\r\nvar zip_DEFAULT_LEVEL = 6;\r\nvar zip_FULL_SEARCH = true;\r\nvar zip_INBUFSIZ = 32768;\t// Input buffer size\r\nvar zip_INBUF_EXTRA = 64;\t// Extra buffer\r\nvar zip_OUTBUFSIZ = 1024 * 8;\r\nvar zip_window_size = 2 * zip_WSIZE;\r\nvar zip_MIN_MATCH = 3;\r\nvar zip_MAX_MATCH = 258;\r\nvar zip_BITS = 16;\r\n// for SMALL_MEM\r\nvar zip_LIT_BUFSIZE = 0x2000;\r\nvar zip_HASH_BITS = 13;\r\n// for MEDIUM_MEM\r\n// var zip_LIT_BUFSIZE = 0x4000;\r\n// var zip_HASH_BITS = 14;\r\n// for BIG_MEM\r\n// var zip_LIT_BUFSIZE = 0x8000;\r\n// var zip_HASH_BITS = 15;\r\nif (zip_LIT_BUFSIZE > zip_INBUFSIZ)\r\n\talert(\"error: zip_INBUFSIZ is too small\");\r\nif ((zip_WSIZE << 1) > (1 << zip_BITS))\r\n\talert(\"error: zip_WSIZE is too large\");\r\nif (zip_HASH_BITS > zip_BITS - 1)\r\n\talert(\"error: zip_HASH_BITS is too large\");\r\nif (zip_HASH_BITS < 8 || zip_MAX_MATCH !== 258)\r\n\talert(\"error: Code too clever\");\r\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\r\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\r\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\r\nvar zip_WMASK = zip_WSIZE - 1;\r\nvar zip_NIL = 0; // Tail of hash chains\r\nvar zip_TOO_FAR = 4096;\r\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\r\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\r\nvar zip_SMALLEST = 1;\r\nvar zip_MAX_BITS = 15;\r\nvar zip_MAX_BL_BITS = 7;\r\nvar zip_LENGTH_CODES = 29;\r\nvar zip_LITERALS = 256;\r\nvar zip_END_BLOCK = 256;\r\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\r\nvar zip_D_CODES = 30;\r\nvar zip_BL_CODES = 19;\r\nvar zip_REP_3_6 = 16;\r\nvar zip_REPZ_3_10 = 17;\r\nvar zip_REPZ_11_138 = 18;\r\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\r\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\r\n\tzip_MIN_MATCH);\r\n\r\n/* variables */\r\nvar zip_free_queue;\r\nvar zip_qhead, zip_qtail;\r\nvar zip_initflag;\r\nvar zip_outbuf = null;\r\nvar zip_outcnt, zip_outoff;\r\nvar zip_complete;\r\nvar zip_window;\r\nvar zip_d_buf;\r\nvar zip_l_buf;\r\nvar zip_prev;\r\nvar zip_bi_buf;\r\nvar zip_bi_valid;\r\nvar zip_block_start;\r\nvar zip_ins_h;\r\nvar zip_hash_head;\r\nvar zip_prev_match;\r\nvar zip_match_available;\r\nvar zip_match_length;\r\nvar zip_prev_length;\r\nvar zip_strstart;\r\nvar zip_match_start;\r\nvar zip_eofile;\r\nvar zip_lookahead;\r\nvar zip_max_chain_length;\r\nvar zip_max_lazy_match;\r\nvar zip_compr_level;\r\nvar zip_good_match;\r\nvar zip_nice_match;\r\nvar zip_dyn_ltree;\r\nvar zip_dyn_dtree;\r\nvar zip_static_ltree;\r\nvar zip_static_dtree;\r\nvar zip_bl_tree;\r\nvar zip_l_desc;\r\nvar zip_d_desc;\r\nvar zip_bl_desc;\r\nvar zip_bl_count;\r\nvar zip_heap;\r\nvar zip_heap_len;\r\nvar zip_heap_max;\r\nvar zip_depth;\r\nvar zip_length_code;\r\nvar zip_dist_code;\r\nvar zip_base_length;\r\nvar zip_base_dist;\r\nvar zip_flag_buf;\r\nvar zip_last_lit;\r\nvar zip_last_dist;\r\nvar zip_last_flags;\r\nvar zip_flags;\r\nvar zip_flag_bit;\r\nvar zip_opt_len;\r\nvar zip_static_len;\r\nvar zip_deflate_data;\r\nvar zip_deflate_pos;\r\n\r\n/* constant tables */\r\nvar zip_extra_lbits = [\r\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\r\nvar zip_extra_dbits = [\r\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\r\nvar zip_extra_blbits = [\r\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\r\nvar zip_bl_order = [\r\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\nvar zip_configuration_table = [\r\n\tnew zip_DeflateConfiguration(0, 0, 0, 0),\r\n\tnew zip_DeflateConfiguration(4, 4, 8, 4),\r\n\tnew zip_DeflateConfiguration(4, 5, 16, 8),\r\n\tnew zip_DeflateConfiguration(4, 6, 32, 32),\r\n\tnew zip_DeflateConfiguration(4, 4, 16, 16),\r\n\tnew zip_DeflateConfiguration(8, 16, 32, 32),\r\n\tnew zip_DeflateConfiguration(8, 16, 128, 128),\r\n\tnew zip_DeflateConfiguration(8, 32, 128, 256),\r\n\tnew zip_DeflateConfiguration(32, 128, 258, 1024),\r\n\tnew zip_DeflateConfiguration(32, 258, 258, 4096)];\r\n\r\n/* objects (deflate) */\r\n\r\nfunction zip_DeflateCT() {\r\n\tthis.fc = 0; // frequency count or bit string\r\n\tthis.dl = 0; // father node in Huffman tree or length of bit string\r\n}\r\n\r\nfunction zip_DeflateTreeDesc() {\r\n\tthis.dyn_tree = null;\t// the dynamic tree\r\n\tthis.static_tree = null;\t// corresponding static tree or NULL\r\n\tthis.extra_bits = null;\t// extra bits for each code or NULL\r\n\tthis.extra_base = 0;\t// base index for extra_bits\r\n\tthis.elems = 0;\t\t// max number of elements in the tree\r\n\tthis.max_length = 0;\t// max bit length for the codes\r\n\tthis.max_code = 0;\t\t// largest code with non zero frequency\r\n}\r\n\r\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\r\n * the desired pack level (0..9). The values given below have been tuned to\r\n * exclude worst case performance for pathological files. Better values may be\r\n * found for specific files.\r\n */\r\nfunction zip_DeflateConfiguration(a, b, c, d) {\r\n\tthis.good_length = a; // reduce lazy search above this match length\r\n\tthis.max_lazy = b;    // do not perform lazy search above this match length\r\n\tthis.nice_length = c; // quit search above this match length\r\n\tthis.max_chain = d;\r\n}\r\n\r\nfunction zip_DeflateBuffer() {\r\n\tthis.next = null;\r\n\tthis.len = 0;\r\n\tthis.ptr = new Array(zip_OUTBUFSIZ);\r\n\tthis.off = 0;\r\n}\r\n\r\n/* routines (deflate) */\r\n\r\nfunction zip_deflate_start(level) {\r\n\tvar i;\r\n\r\n\tif (!level)\r\n\t\tlevel = zip_DEFAULT_LEVEL;\r\n\telse if (level < 1)\r\n\t\tlevel = 1;\r\n\telse if (level > 9)\r\n\t\tlevel = 9;\r\n\r\n\tzip_compr_level = level;\r\n\tzip_initflag = false;\r\n\tzip_eofile = false;\r\n\tif (zip_outbuf !== null)\r\n\t\treturn;\r\n\r\n\tzip_free_queue = zip_qhead = zip_qtail = null;\r\n\tzip_outbuf = new Array(zip_OUTBUFSIZ);\r\n\tzip_window = new Array(zip_window_size);\r\n\tzip_d_buf = new Array(zip_DIST_BUFSIZE);\r\n\tzip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\r\n\tzip_prev = new Array(1 << zip_BITS);\r\n\tzip_dyn_ltree = new Array(zip_HEAP_SIZE);\r\n\tfor (i = 0; i < zip_HEAP_SIZE; i++)\r\n\t\tzip_dyn_ltree[i] = new zip_DeflateCT();\r\n\tzip_dyn_dtree = new Array(2 * zip_D_CODES + 1);\r\n\tfor (i = 0; i < 2 * zip_D_CODES + 1; i++)\r\n\t\tzip_dyn_dtree[i] = new zip_DeflateCT();\r\n\tzip_static_ltree = new Array(zip_L_CODES + 2);\r\n\tfor (i = 0; i < zip_L_CODES + 2; i++)\r\n\t\tzip_static_ltree[i] = new zip_DeflateCT();\r\n\tzip_static_dtree = new Array(zip_D_CODES);\r\n\tfor (i = 0; i < zip_D_CODES; i++)\r\n\t\tzip_static_dtree[i] = new zip_DeflateCT();\r\n\tzip_bl_tree = new Array(2 * zip_BL_CODES + 1);\r\n\tfor (i = 0; i < 2 * zip_BL_CODES + 1; i++)\r\n\t\tzip_bl_tree[i] = new zip_DeflateCT();\r\n\tzip_l_desc = new zip_DeflateTreeDesc();\r\n\tzip_d_desc = new zip_DeflateTreeDesc();\r\n\tzip_bl_desc = new zip_DeflateTreeDesc();\r\n\tzip_bl_count = new Array(zip_MAX_BITS + 1);\r\n\tzip_heap = new Array(2 * zip_L_CODES + 1);\r\n\tzip_depth = new Array(2 * zip_L_CODES + 1);\r\n\tzip_length_code = new Array(zip_MAX_MATCH - zip_MIN_MATCH + 1);\r\n\tzip_dist_code = new Array(512);\r\n\tzip_base_length = new Array(zip_LENGTH_CODES);\r\n\tzip_base_dist = new Array(zip_D_CODES);\r\n\tzip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\r\n}\r\n\r\nfunction zip_reuse_queue(p) {\r\n\tp.next = zip_free_queue;\r\n\tzip_free_queue = p;\r\n}\r\n\r\nfunction zip_new_queue() {\r\n\tvar p;\r\n\r\n\tif (zip_free_queue !== null) {\r\n\t\tp = zip_free_queue;\r\n\t\tzip_free_queue = zip_free_queue.next;\r\n\t}\r\n\telse\r\n\t\tp = new zip_DeflateBuffer();\r\n\tp.next = null;\r\n\tp.len = p.off = 0;\r\n\r\n\treturn p;\r\n}\r\n\r\nfunction zip_head1(i) {\r\n\treturn zip_prev[zip_WSIZE + i];\r\n}\r\n\r\nfunction zip_head2(i, val) {\r\n\treturn zip_prev[zip_WSIZE + i] = val;\r\n}\r\n\r\n/* put_byte is used for the compressed output, put_ubyte for the\r\n * uncompressed output. However unlzw() uses window for its\r\n * suffix table instead of its output buffer, so it does not use put_ubyte\r\n * (to be cleaned up).\r\n */\r\nfunction zip_put_byte(c) {\r\n\tzip_outbuf[zip_outoff + zip_outcnt++] = c;\r\n\tif (zip_outoff + zip_outcnt === zip_OUTBUFSIZ)\r\n\t\tzip_qoutbuf();\r\n}\r\n\r\n/* Output a 16 bit value, lsb first */\r\nfunction zip_put_short(w) {\r\n\tw &= 0xffff;\r\n\tif (zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\r\n\t\tzip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\r\n\t\tzip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\r\n\t} else {\r\n\t\tzip_put_byte(w & 0xff);\r\n\t\tzip_put_byte(w >>> 8);\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Insert string s in the dictionary and set match_head to the previous head\r\n * of the hash chain (the most recent string with same hash key). Return\r\n * the previous length of the hash chain.\r\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\r\n *    input characters and the first MIN_MATCH bytes of s are valid\r\n *    (except for the last MIN_MATCH-1 bytes of the input file).\r\n */\r\nfunction zip_INSERT_STRING() {\r\n\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT)\r\n\t\t^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\r\n\t\t& zip_HASH_MASK;\r\n\tzip_hash_head = zip_head1(zip_ins_h);\r\n\tzip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\r\n\tzip_head2(zip_ins_h, zip_strstart);\r\n}\r\n\r\n/* Send a code of the given tree. c and tree must not have side effects */\r\nfunction zip_SEND_CODE(c, tree) {\r\n\tzip_send_bits(tree[c].fc, tree[c].dl);\r\n}\r\n\r\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\r\n * must not have side effects. dist_code[256] and dist_code[257] are never\r\n * used.\r\n */\r\nfunction zip_D_CODE(dist) {\r\n\treturn (dist < 256 ? zip_dist_code[dist]\r\n\t\t: zip_dist_code[256 + (dist >> 7)]) & 0xff;\r\n}\r\n\r\n/* ==========================================================================\r\n * Compares to subtrees, using the tree depth as tie breaker when\r\n * the subtrees have equal frequency. This minimizes the worst case length.\r\n */\r\nfunction zip_SMALLER(tree, n, m) {\r\n\treturn tree[n].fc < tree[m].fc ||\r\n\t\t(tree[n].fc === tree[m].fc && zip_depth[n] <= zip_depth[m]);\r\n}\r\n\r\n/* ==========================================================================\r\n * read string data\r\n */\r\nfunction zip_read_buff(buff, offset, n) {\r\n\tvar i;\r\n\tfor (i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\r\n\t\tbuff[offset + i] =\r\n\t\t\tzip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\r\n\treturn i;\r\n}\r\n\r\n/* ==========================================================================\r\n * Initialize the \"longest match\" routines for a new file\r\n */\r\nfunction zip_lm_init() {\r\n\tvar j;\r\n\r\n\t/* Initialize the hash table. */\r\n\tfor (j = 0; j < zip_HASH_SIZE; j++)\r\n\t\t//\tzip_head2(j, zip_NIL);\r\n\t\tzip_prev[zip_WSIZE + j] = 0;\r\n\t/* prev will be initialized on the fly */\r\n\r\n    /* Set the default configuration parameters:\r\n     */\r\n\tzip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\r\n\tzip_good_match = zip_configuration_table[zip_compr_level].good_length;\r\n\tif (!zip_FULL_SEARCH)\r\n\t\tzip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\r\n\tzip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\r\n\r\n\tzip_strstart = 0;\r\n\tzip_block_start = 0;\r\n\r\n\tzip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\r\n\tif (zip_lookahead <= 0) {\r\n\t\tzip_eofile = true;\r\n\t\tzip_lookahead = 0;\r\n\t\treturn;\r\n\t}\r\n\tzip_eofile = false;\r\n    /* Make sure that we always have enough lookahead. This is important\r\n     * if input comes from a device such as a tty.\r\n     */\r\n\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\r\n\t\tzip_fill_window();\r\n\r\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\r\n     * not important since only literal bytes will be emitted.\r\n     */\r\n\tzip_ins_h = 0;\r\n\tfor (j = 0; j < zip_MIN_MATCH - 1; j++) {\r\n\t\t//      UPDATE_HASH(ins_h, window[j]);\r\n\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Set match_start to the longest match starting at the given string and\r\n * return its length. Matches shorter or equal to prev_length are discarded,\r\n * in which case the result is equal to prev_length and match_start is\r\n * garbage.\r\n * IN assertions: cur_match is the head of the hash chain for the current\r\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\r\n */\r\nfunction zip_longest_match(cur_match) {\r\n\tvar chain_length = zip_max_chain_length; // max hash chain length\r\n\tvar scanp = zip_strstart; // current string\r\n\tvar matchp;\t\t// matched string\r\n\tvar len;\t\t// length of current match\r\n\tvar best_len = zip_prev_length;\t// best match length so far\r\n\r\n    /* Stop when cur_match becomes <= limit. To simplify the code,\r\n     * we prevent matches with the string of window index 0.\r\n     */\r\n\tvar limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\r\n\r\n\tvar strendp = zip_strstart + zip_MAX_MATCH;\r\n\tvar scan_end1 = zip_window[scanp + best_len - 1];\r\n\tvar scan_end = zip_window[scanp + best_len];\r\n\r\n\t/* Do not waste too much time if we already have a good match: */\r\n\tif (zip_prev_length >= zip_good_match)\r\n\t\tchain_length >>= 2;\r\n\r\n\t//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\r\n\r\n\tdo {\r\n\t\t//    Assert(cur_match < encoder->strstart, \"no future\");\r\n\t\tmatchp = cur_match;\r\n\r\n\t\t/* Skip to next match if the match length cannot increase\r\n\t\t\t* or if the match length is less than 2:\r\n\t\t*/\r\n\t\tif (zip_window[matchp + best_len] !== scan_end ||\r\n\t\t\tzip_window[matchp + best_len - 1] !== scan_end1 ||\r\n\t\t\tzip_window[matchp] !== zip_window[scanp] ||\r\n\t\t\tzip_window[++matchp] !== zip_window[scanp + 1]) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/* The check at best_len-1 can be removed because it will be made\r\n\t\t\t * again later. (This heuristic is not always a win.)\r\n\t\t\t * It is not necessary to compare scan[2] and match[2] since they\r\n\t\t\t * are always equal when the other bytes match, given that\r\n\t\t\t * the hash keys are equal and that HASH_BITS >= 8.\r\n\t\t\t */\r\n\t\tscanp += 2;\r\n\t\tmatchp++;\r\n\r\n\t\t/* We check for insufficient lookahead only every 8th comparison;\r\n\t\t\t * the 256th check will be made at strstart+258.\r\n\t\t\t */\r\n\t\tdo {\r\n\t\t} while (zip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\r\n\t\t\tscanp < strendp);\r\n\r\n\t\tlen = zip_MAX_MATCH - (strendp - scanp);\r\n\t\tscanp = strendp - zip_MAX_MATCH;\r\n\r\n\t\tif (len > best_len) {\r\n\t\t\tzip_match_start = cur_match;\r\n\t\t\tbest_len = len;\r\n\t\t\tif (zip_FULL_SEARCH) {\r\n\t\t\t\tif (len >= zip_MAX_MATCH) break;\r\n\t\t\t} else {\r\n\t\t\t\tif (len >= zip_nice_match) break;\r\n\t\t\t}\r\n\r\n\t\t\tscan_end1 = zip_window[scanp + best_len - 1];\r\n\t\t\tscan_end = zip_window[scanp + best_len];\r\n\t\t}\r\n\t} while ((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\r\n\t\t&& --chain_length !== 0);\r\n\r\n\treturn best_len;\r\n}\r\n\r\n/* ==========================================================================\r\n * Fill the window when the lookahead becomes insufficient.\r\n * Updates strstart and lookahead, and sets eofile if end of input file.\r\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\r\n * OUT assertions: at least one byte has been read, or eofile is set;\r\n *    file reads are performed for at least two bytes (required for the\r\n *    translate_eol option).\r\n */\r\nfunction zip_fill_window() {\r\n\tvar n, m;\r\n\r\n\t// Amount of free space at the end of the window.\r\n\tvar more = zip_window_size - zip_lookahead - zip_strstart;\r\n\r\n    /* If the window is almost full and there is insufficient lookahead,\r\n     * move the upper half to the lower one to make room in the upper half.\r\n     */\r\n\tif (more === -1) {\r\n\t\t/* Very unlikely, but possible on 16 bit machine if strstart === 0\r\n\t\t\t * and lookahead === 1 (input done one byte at time)\r\n\t\t\t */\r\n\t\tmore--;\r\n\t} else if (zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\r\n\t\t/* By the IN assertion, the window is not empty so we can't confuse\r\n\t\t\t * more === 0 with more === 64K on a 16 bit machine.\r\n\t\t\t */\r\n\t\t//\tAssert(window_size === (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\r\n\r\n\t\t//\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\r\n\t\tfor (n = 0; n < zip_WSIZE; n++)\r\n\t\t\tzip_window[n] = zip_window[n + zip_WSIZE];\r\n\r\n\t\tzip_match_start -= zip_WSIZE;\r\n\t\tzip_strstart -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\r\n\t\tzip_block_start -= zip_WSIZE;\r\n\r\n\t\tfor (n = 0; n < zip_HASH_SIZE; n++) {\r\n\t\t\tm = zip_head1(n);\r\n\t\t\tzip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\r\n\t\t}\r\n\t\tfor (n = 0; n < zip_WSIZE; n++) {\r\n\t\t\t/* If n is not on any hash chain, prev[n] is garbage but\r\n\t\t\t * its value will never be used.\r\n\t\t\t */\r\n\t\t\tm = zip_prev[n];\r\n\t\t\tzip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\r\n\t\t}\r\n\t\tmore += zip_WSIZE;\r\n\t}\r\n\t// At this point, more >= 2\r\n\tif (!zip_eofile) {\r\n\t\tn = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\r\n\t\tif (n <= 0)\r\n\t\t\tzip_eofile = true;\r\n\t\telse\r\n\t\t\tzip_lookahead += n;\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Processes a new input file and return its compressed length. This\r\n * function does not perform lazy evaluationof matches and inserts\r\n * new strings in the dictionary only for unmatched strings or for short\r\n * matches. It is used only for the fast compression options.\r\n */\r\nfunction zip_deflate_fast() {\r\n\twhile (zip_lookahead !== 0 && zip_qhead === null) {\r\n\t\tvar flush; // set if current block must be flushed\r\n\r\n\t\t/* Insert the string window[strstart .. strstart+2] in the\r\n\t\t * dictionary, and set hash_head to the head of the hash chain:\r\n\t\t */\r\n\t\tzip_INSERT_STRING();\r\n\r\n\t\t/* Find the longest match, discarding those <= prev_length.\r\n\t\t * At this point we have always match_length < MIN_MATCH\r\n\t\t */\r\n\t\tif (zip_hash_head !== zip_NIL &&\r\n\t\t\tzip_strstart - zip_hash_head <= zip_MAX_DIST) {\r\n\t\t\t/* To simplify the code, we prevent matches with the string\r\n\t\t\t * of window index 0 (in particular we have to avoid a match\r\n\t\t\t * of the string with itself at the start of the input file).\r\n\t\t\t */\r\n\t\t\tzip_match_length = zip_longest_match(zip_hash_head);\r\n\t\t\t/* longest_match() sets match_start */\r\n\t\t\tif (zip_match_length > zip_lookahead)\r\n\t\t\t\tzip_match_length = zip_lookahead;\r\n\t\t}\r\n\t\tif (zip_match_length >= zip_MIN_MATCH) {\r\n\t\t\t//\t    check_match(strstart, match_start, match_length);\r\n\r\n\t\t\tflush = zip_ct_tally(zip_strstart - zip_match_start,\r\n\t\t\t\tzip_match_length - zip_MIN_MATCH);\r\n\t\t\tzip_lookahead -= zip_match_length;\r\n\r\n\t\t\t/* Insert new strings in the hash table only if the match length\r\n\t\t\t * is not too large. This saves time but degrades compression.\r\n\t\t\t */\r\n\t\t\tif (zip_match_length <= zip_max_lazy_match) {\r\n\t\t\t\tzip_match_length--; // string at strstart already in hash table\r\n\t\t\t\tdo {\r\n\t\t\t\t\tzip_strstart++;\r\n\t\t\t\t\tzip_INSERT_STRING();\r\n\t\t\t\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n\t\t\t\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\r\n\t\t\t\t\t * these bytes are garbage, but it does not matter since\r\n\t\t\t\t\t * the next lookahead bytes will be emitted as literals.\r\n\t\t\t\t\t */\r\n\t\t\t\t} while (--zip_match_length !== 0);\r\n\t\t\t\tzip_strstart++;\r\n\t\t\t} else {\r\n\t\t\t\tzip_strstart += zip_match_length;\r\n\t\t\t\tzip_match_length = 0;\r\n\t\t\t\tzip_ins_h = zip_window[zip_strstart] & 0xff;\r\n\t\t\t\t//\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\r\n\t\t\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\r\n\r\n\t\t\t\t//#if MIN_MATCH !== 3\r\n\t\t\t\t//\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\r\n\t\t\t\t//#endif\r\n\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t/* No match, output a literal byte */\r\n\t\t\tflush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\r\n\t\t\tzip_lookahead--;\r\n\t\t\tzip_strstart++;\r\n\t\t}\r\n\t\tif (flush) {\r\n\t\t\tzip_flush_block(0);\r\n\t\t\tzip_block_start = zip_strstart;\r\n\t\t}\r\n\r\n\t\t/* Make sure that we always have enough lookahead, except\r\n\t\t * at the end of the input file. We need MAX_MATCH bytes\r\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\r\n\t\t * string following the next match.\r\n\t\t */\r\n\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\r\n\t\t\tzip_fill_window();\r\n\t}\r\n}\r\n\r\nfunction zip_deflate_better() {\r\n\t/* Process the input block. */\r\n\twhile (zip_lookahead !== 0 && zip_qhead === null) {\r\n\t\t/* Insert the string window[strstart .. strstart+2] in the\r\n\t\t * dictionary, and set hash_head to the head of the hash chain:\r\n\t\t */\r\n\t\tzip_INSERT_STRING();\r\n\r\n\t\t/* Find the longest match, discarding those <= prev_length.\r\n\t\t */\r\n\t\tzip_prev_length = zip_match_length;\r\n\t\tzip_prev_match = zip_match_start;\r\n\t\tzip_match_length = zip_MIN_MATCH - 1;\r\n\r\n\t\tif (zip_hash_head !== zip_NIL &&\r\n\t\t\tzip_prev_length < zip_max_lazy_match &&\r\n\t\t\tzip_strstart - zip_hash_head <= zip_MAX_DIST) {\r\n\t\t\t/* To simplify the code, we prevent matches with the string\r\n\t\t\t * of window index 0 (in particular we have to avoid a match\r\n\t\t\t * of the string with itself at the start of the input file).\r\n\t\t\t */\r\n\t\t\tzip_match_length = zip_longest_match(zip_hash_head);\r\n\t\t\t/* longest_match() sets match_start */\r\n\t\t\tif (zip_match_length > zip_lookahead)\r\n\t\t\t\tzip_match_length = zip_lookahead;\r\n\r\n\t\t\t/* Ignore a length 3 match if it is too distant: */\r\n\t\t\tif (zip_match_length === zip_MIN_MATCH &&\r\n\t\t\t\tzip_strstart - zip_match_start > zip_TOO_FAR) {\r\n\t\t\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\r\n\t\t\t\t * but we will ignore the current match anyway.\r\n\t\t\t\t */\r\n\t\t\t\tzip_match_length--;\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* If there was a match at the previous step and the current\r\n\t\t * match is not better, output the previous match:\r\n\t\t */\r\n\t\tif (zip_prev_length >= zip_MIN_MATCH &&\r\n\t\t\tzip_match_length <= zip_prev_length) {\r\n\t\t\tvar flush; // set if current block must be flushed\r\n\r\n\t\t\t//\t    check_match(strstart - 1, prev_match, prev_length);\r\n\t\t\tflush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\r\n\t\t\t\tzip_prev_length - zip_MIN_MATCH);\r\n\r\n\t\t\t/* Insert in hash table all strings up to the end of the match.\r\n\t\t\t * strstart-1 and strstart are already inserted.\r\n\t\t\t */\r\n\t\t\tzip_lookahead -= zip_prev_length - 1;\r\n\t\t\tzip_prev_length -= 2;\r\n\t\t\tdo {\r\n\t\t\t\tzip_strstart++;\r\n\t\t\t\tzip_INSERT_STRING();\r\n\t\t\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n\t\t\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\r\n\t\t\t\t * these bytes are garbage, but it does not matter since the\r\n\t\t\t\t * next lookahead bytes will always be emitted as literals.\r\n\t\t\t\t */\r\n\t\t\t} while (--zip_prev_length !== 0);\r\n\t\t\tzip_match_available = 0;\r\n\t\t\tzip_match_length = zip_MIN_MATCH - 1;\r\n\t\t\tzip_strstart++;\r\n\t\t\tif (flush) {\r\n\t\t\t\tzip_flush_block(0);\r\n\t\t\t\tzip_block_start = zip_strstart;\r\n\t\t\t}\r\n\t\t} else if (zip_match_available !== 0) {\r\n\t\t\t/* If there was no match at the previous position, output a\r\n\t\t\t * single literal. If there was a match but the current match\r\n\t\t\t * is longer, truncate the previous match to a single literal.\r\n\t\t\t */\r\n\t\t\tif (zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\r\n\t\t\t\tzip_flush_block(0);\r\n\t\t\t\tzip_block_start = zip_strstart;\r\n\t\t\t}\r\n\t\t\tzip_strstart++;\r\n\t\t\tzip_lookahead--;\r\n\t\t} else {\r\n\t\t\t/* There is no previous match to compare with, wait for\r\n\t\t\t * the next step to decide.\r\n\t\t\t */\r\n\t\t\tzip_match_available = 1;\r\n\t\t\tzip_strstart++;\r\n\t\t\tzip_lookahead--;\r\n\t\t}\r\n\r\n\t\t/* Make sure that we always have enough lookahead, except\r\n\t\t * at the end of the input file. We need MAX_MATCH bytes\r\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\r\n\t\t * string following the next match.\r\n\t\t */\r\n\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\r\n\t\t\tzip_fill_window();\r\n\t}\r\n}\r\n\r\nfunction zip_init_deflate() {\r\n\tif (zip_eofile)\r\n\t\treturn;\r\n\tzip_bi_buf = 0;\r\n\tzip_bi_valid = 0;\r\n\tzip_ct_init();\r\n\tzip_lm_init();\r\n\r\n\tzip_qhead = null;\r\n\tzip_outcnt = 0;\r\n\tzip_outoff = 0;\r\n\r\n\tif (zip_compr_level <= 3) {\r\n\t\tzip_prev_length = zip_MIN_MATCH - 1;\r\n\t\tzip_match_length = 0;\r\n\t}\r\n\telse {\r\n\t\tzip_match_length = zip_MIN_MATCH - 1;\r\n\t\tzip_match_available = 0;\r\n\t}\r\n\r\n\tzip_complete = false;\r\n}\r\n\r\n/* ==========================================================================\r\n * Same as above, but achieves better compression. We use a lazy\r\n * evaluation for matches: a match is finally adopted only if there is\r\n * no better match at the next window position.\r\n */\r\nfunction zip_deflate_internal(buff, off, buff_size) {\r\n\tvar n;\r\n\r\n\tif (!zip_initflag) {\r\n\t\tzip_init_deflate();\r\n\t\tzip_initflag = true;\r\n\t\tif (zip_lookahead === 0) { // empty\r\n\t\t\tzip_complete = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif ((n = zip_qcopy(buff, off, buff_size)) === buff_size)\r\n\t\treturn buff_size;\r\n\r\n\tif (zip_complete)\r\n\t\treturn n;\r\n\r\n\tif (zip_compr_level <= 3) // optimized for speed\r\n\t\tzip_deflate_fast();\r\n\telse\r\n\t\tzip_deflate_better();\r\n\tif (zip_lookahead === 0) {\r\n\t\tif (zip_match_available !== 0)\r\n\t\t\tzip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\r\n\t\tzip_flush_block(1);\r\n\t\tzip_complete = true;\r\n\t}\r\n\treturn n + zip_qcopy(buff, n + off, buff_size - n);\r\n}\r\n\r\nfunction zip_qcopy(buff, off, buff_size) {\r\n\tvar n, i, j;\r\n\r\n\tn = 0;\r\n\twhile (zip_qhead !== null && n < buff_size) {\r\n\t\ti = buff_size - n;\r\n\t\tif (i > zip_qhead.len)\r\n\t\t\ti = zip_qhead.len;\r\n\t\t//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\r\n\t\tfor (j = 0; j < i; j++)\r\n\t\t\tbuff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\r\n\r\n\t\tzip_qhead.off += i;\r\n\t\tzip_qhead.len -= i;\r\n\t\tn += i;\r\n\t\tif (zip_qhead.len === 0) {\r\n\t\t\tvar p;\r\n\t\t\tp = zip_qhead;\r\n\t\t\tzip_qhead = zip_qhead.next;\r\n\t\t\tzip_reuse_queue(p);\r\n\t\t}\r\n\t}\r\n\r\n\tif (n === buff_size)\r\n\t\treturn n;\r\n\r\n\tif (zip_outoff < zip_outcnt) {\r\n\t\ti = buff_size - n;\r\n\t\tif (i > zip_outcnt - zip_outoff)\r\n\t\t\ti = zip_outcnt - zip_outoff;\r\n\t\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\r\n\t\tfor (j = 0; j < i; j++)\r\n\t\t\tbuff[off + n + j] = zip_outbuf[zip_outoff + j];\r\n\t\tzip_outoff += i;\r\n\t\tn += i;\r\n\t\tif (zip_outcnt === zip_outoff)\r\n\t\t\tzip_outcnt = zip_outoff = 0;\r\n\t}\r\n\treturn n;\r\n}\r\n\r\n/* ==========================================================================\r\n * Allocate the match buffer, initialize the various tables and save the\r\n * location of the internal file attribute (ascii/binary) and method\r\n * (DEFLATE/STORE).\r\n */\r\nfunction zip_ct_init() {\r\n\tvar n;\t// iterates over tree elements\r\n\tvar bits;\t// bit counter\r\n\tvar length;\t// length value\r\n\tvar code;\t// code value\r\n\tvar dist;\t// distance index\r\n\r\n\tif (zip_static_dtree[0].dl !== 0) return; // ct_init already called\r\n\r\n\tzip_l_desc.dyn_tree = zip_dyn_ltree;\r\n\tzip_l_desc.static_tree = zip_static_ltree;\r\n\tzip_l_desc.extra_bits = zip_extra_lbits;\r\n\tzip_l_desc.extra_base = zip_LITERALS + 1;\r\n\tzip_l_desc.elems = zip_L_CODES;\r\n\tzip_l_desc.max_length = zip_MAX_BITS;\r\n\tzip_l_desc.max_code = 0;\r\n\r\n\tzip_d_desc.dyn_tree = zip_dyn_dtree;\r\n\tzip_d_desc.static_tree = zip_static_dtree;\r\n\tzip_d_desc.extra_bits = zip_extra_dbits;\r\n\tzip_d_desc.extra_base = 0;\r\n\tzip_d_desc.elems = zip_D_CODES;\r\n\tzip_d_desc.max_length = zip_MAX_BITS;\r\n\tzip_d_desc.max_code = 0;\r\n\r\n\tzip_bl_desc.dyn_tree = zip_bl_tree;\r\n\tzip_bl_desc.static_tree = null;\r\n\tzip_bl_desc.extra_bits = zip_extra_blbits;\r\n\tzip_bl_desc.extra_base = 0;\r\n\tzip_bl_desc.elems = zip_BL_CODES;\r\n\tzip_bl_desc.max_length = zip_MAX_BL_BITS;\r\n\tzip_bl_desc.max_code = 0;\r\n\r\n\t// Initialize the mapping length (0..255) -> length code (0..28)\r\n\tlength = 0;\r\n\tfor (code = 0; code < zip_LENGTH_CODES - 1; code++) {\r\n\t\tzip_base_length[code] = length;\r\n\t\tfor (n = 0; n < (1 << zip_extra_lbits[code]); n++)\r\n\t\t\tzip_length_code[length++] = code;\r\n\t}\r\n\t// Assert (length === 256, \"ct_init: length !== 256\");\r\n\r\n    /* Note that the length 255 (match length 258) can be represented\r\n     * in two different ways: code 284 + 5 bits or code 285, so we\r\n     * overwrite length_code[255] to use the best encoding:\r\n     */\r\n\tzip_length_code[length - 1] = code;\r\n\r\n\t/* Initialize the mapping dist (0..32K) -> dist code (0..29) */\r\n\tdist = 0;\r\n\tfor (code = 0; code < 16; code++) {\r\n\t\tzip_base_dist[code] = dist;\r\n\t\tfor (n = 0; n < (1 << zip_extra_dbits[code]); n++) {\r\n\t\t\tzip_dist_code[dist++] = code;\r\n\t\t}\r\n\t}\r\n\t// Assert (dist === 256, \"ct_init: dist !== 256\");\r\n\tdist >>= 7; // from now on, all distances are divided by 128\r\n\tfor (; code < zip_D_CODES; code++) {\r\n\t\tzip_base_dist[code] = dist << 7;\r\n\t\tfor (n = 0; n < (1 << (zip_extra_dbits[code] - 7)); n++)\r\n\t\t\tzip_dist_code[256 + dist++] = code;\r\n\t}\r\n\t// Assert (dist === 256, \"ct_init: 256+dist !== 512\");\r\n\r\n\t// Construct the codes of the static literal tree\r\n\tfor (bits = 0; bits <= zip_MAX_BITS; bits++)\r\n\t\tzip_bl_count[bits] = 0;\r\n\tn = 0;\r\n\twhile (n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\r\n\twhile (n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\r\n\twhile (n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\r\n\twhile (n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\r\n    /* Codes 286 and 287 do not exist, but we must include them in the\r\n     * tree construction to get a canonical Huffman tree (longest code\r\n     * all ones)\r\n     */\r\n\tzip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\r\n\r\n\t/* The static distance tree is trivial: */\r\n\tfor (n = 0; n < zip_D_CODES; n++) {\r\n\t\tzip_static_dtree[n].dl = 5;\r\n\t\tzip_static_dtree[n].fc = zip_bi_reverse(n, 5);\r\n\t}\r\n\r\n\t// Initialize the first block of the first file:\r\n\tzip_init_block();\r\n}\r\n\r\n/* ==========================================================================\r\n * Initialize a new block.\r\n */\r\nfunction zip_init_block() {\r\n\tvar n; // iterates over tree elements\r\n\r\n\t// Initialize the trees.\r\n\tfor (n = 0; n < zip_L_CODES; n++) zip_dyn_ltree[n].fc = 0;\r\n\tfor (n = 0; n < zip_D_CODES; n++) zip_dyn_dtree[n].fc = 0;\r\n\tfor (n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\r\n\r\n\tzip_dyn_ltree[zip_END_BLOCK].fc = 1;\r\n\tzip_opt_len = zip_static_len = 0;\r\n\tzip_last_lit = zip_last_dist = zip_last_flags = 0;\r\n\tzip_flags = 0;\r\n\tzip_flag_bit = 1;\r\n}\r\n\r\n/* ==========================================================================\r\n * Restore the heap property by moving down the tree starting at node k,\r\n * exchanging a node with the smallest of its two sons if necessary, stopping\r\n * when the heap property is re-established (each father smaller than its\r\n * two sons).\r\n */\r\nfunction zip_pqdownheap(\r\n\ttree,\t// the tree to restore\r\n\tk) {\t// node to move down\r\n\tvar v = zip_heap[k];\r\n\tvar j = k << 1;\t// left son of k\r\n\r\n\twhile (j <= zip_heap_len) {\r\n\t\t// Set j to the smallest of the two sons:\r\n\t\tif (j < zip_heap_len &&\r\n\t\t\tzip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\r\n\t\t\tj++;\r\n\r\n\t\t// Exit if v is smaller than both sons\r\n\t\tif (zip_SMALLER(tree, v, zip_heap[j]))\r\n\t\t\tbreak;\r\n\r\n\t\t// Exchange v with the smallest son\r\n\t\tzip_heap[k] = zip_heap[j];\r\n\t\tk = j;\r\n\r\n\t\t// And continue down the tree, setting j to the left son of k\r\n\t\tj <<= 1;\r\n\t}\r\n\tzip_heap[k] = v;\r\n}\r\n\r\n/* ==========================================================================\r\n * Compute the optimal bit lengths for a tree and update the total bit length\r\n * for the current block.\r\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\r\n *    above are the tree nodes sorted by increasing frequency.\r\n * OUT assertions: the field len is set to the optimal bit length, the\r\n *     array bl_count contains the frequencies for each bit length.\r\n *     The length opt_len is updated; static_len is also updated if stree is\r\n *     not null.\r\n */\r\nfunction zip_gen_bitlen(desc) { // the tree descriptor\r\n\tvar tree = desc.dyn_tree;\r\n\tvar extra = desc.extra_bits;\r\n\tvar base = desc.extra_base;\r\n\tvar max_code = desc.max_code;\r\n\tvar max_length = desc.max_length;\r\n\tvar stree = desc.static_tree;\r\n\tvar h;\t\t// heap index\r\n\tvar n, m;\t\t// iterate over the tree elements\r\n\tvar bits;\t\t// bit length\r\n\tvar xbits;\t\t// extra bits\r\n\tvar f;\t\t// frequency\r\n\tvar overflow = 0;\t// number of elements with bit length too large\r\n\r\n\tfor (bits = 0; bits <= zip_MAX_BITS; bits++)\r\n\t\tzip_bl_count[bits] = 0;\r\n\r\n    /* In a first pass, compute the optimal bit lengths (which may\r\n     * overflow in the case of the bit length tree).\r\n     */\r\n\ttree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\r\n\r\n\tfor (h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\r\n\t\tn = zip_heap[h];\r\n\t\tbits = tree[tree[n].dl].dl + 1;\r\n\t\tif (bits > max_length) {\r\n\t\t\tbits = max_length;\r\n\t\t\toverflow++;\r\n\t\t}\r\n\t\ttree[n].dl = bits;\r\n\t\t// We overwrite tree[n].dl which is no longer needed\r\n\r\n\t\tif (n > max_code)\r\n\t\t\tcontinue; // not a leaf node\r\n\r\n\t\tzip_bl_count[bits]++;\r\n\t\txbits = 0;\r\n\t\tif (n >= base)\r\n\t\t\txbits = extra[n - base];\r\n\t\tf = tree[n].fc;\r\n\t\tzip_opt_len += f * (bits + xbits);\r\n\t\tif (stree !== null)\r\n\t\t\tzip_static_len += f * (stree[n].dl + xbits);\r\n\t}\r\n\tif (overflow === 0)\r\n\t\treturn;\r\n\r\n\t// This happens for example on obj2 and pic of the Calgary corpus\r\n\r\n\t// Find the first bit length which could increase:\r\n\tdo {\r\n\t\tbits = max_length - 1;\r\n\t\twhile (zip_bl_count[bits] === 0)\r\n\t\t\tbits--;\r\n\t\tzip_bl_count[bits]--;\t\t// move one leaf down the tree\r\n\t\tzip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\r\n\t\tzip_bl_count[max_length]--;\r\n\t\t/* The brother of the overflow item also moves one step up,\r\n\t\t * but this does not affect bl_count[max_length]\r\n\t\t */\r\n\t\toverflow -= 2;\r\n\t} while (overflow > 0);\r\n\r\n    /* Now recompute all bit lengths, scanning in increasing frequency.\r\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\r\n     * lengths instead of fixing only the wrong ones. This idea is taken\r\n     * from 'ar' written by Haruhiko Okumura.)\r\n     */\r\n\tfor (bits = max_length; bits !== 0; bits--) {\r\n\t\tn = zip_bl_count[bits];\r\n\t\twhile (n !== 0) {\r\n\t\t\tm = zip_heap[--h];\r\n\t\t\tif (m > max_code)\r\n\t\t\t\tcontinue;\r\n\t\t\tif (tree[m].dl !== bits) {\r\n\t\t\t\tzip_opt_len += (bits - tree[m].dl) * tree[m].fc;\r\n\t\t\t\ttree[m].fc = bits;\r\n\t\t\t}\r\n\t\t\tn--;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Generate the codes for a given tree and bit counts (which need not be\r\n * optimal).\r\n * IN assertion: the array bl_count contains the bit length statistics for\r\n * the given tree and the field len is set for all tree elements.\r\n * OUT assertion: the field code is set for all tree elements of non\r\n *     zero code length.\r\n */\r\nfunction zip_gen_codes(tree,\t// the tree to decorate\r\n\tmax_code) {\t// largest code with non zero frequency\r\n\tvar next_code = new Array(zip_MAX_BITS + 1); // next code value for each bit length\r\n\tvar code = 0;\t\t// running code value\r\n\tvar bits;\t\t\t// bit index\r\n\tvar n;\t\t\t// code index\r\n\r\n    /* The distribution counts are first used to generate the code values\r\n     * without bit reversal.\r\n     */\r\n\tfor (bits = 1; bits <= zip_MAX_BITS; bits++) {\r\n\t\tcode = ((code + zip_bl_count[bits - 1]) << 1);\r\n\t\tnext_code[bits] = code;\r\n\t}\r\n\r\n    /* Check that the bit counts in bl_count are consistent. The last code\r\n     * must be all ones.\r\n     */\r\n\t//    Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1,\r\n\t//\t    \"inconsistent bit counts\");\r\n\t//    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\r\n\r\n\tfor (n = 0; n <= max_code; n++) {\r\n\t\tvar len = tree[n].dl;\r\n\t\tif (len === 0)\r\n\t\t\tcontinue;\r\n\t\t// Now reverse the bits\r\n\t\ttree[n].fc = zip_bi_reverse(next_code[len]++, len);\r\n\r\n\t\t//      Tracec(tree !== static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\r\n\t\t//\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Construct one Huffman tree and assigns the code bit strings and lengths.\r\n * Update the total bit length for the current block.\r\n * IN assertion: the field freq is set for all tree elements.\r\n * OUT assertions: the fields len and code are set to the optimal bit length\r\n *     and corresponding code. The length opt_len is updated; static_len is\r\n *     also updated if stree is not null. The field max_code is set.\r\n */\r\nfunction zip_build_tree(desc) { // the tree descriptor\r\n\tvar tree = desc.dyn_tree;\r\n\tvar stree = desc.static_tree;\r\n\tvar elems = desc.elems;\r\n\tvar n, m;\t\t// iterate over heap elements\r\n\tvar max_code = -1;\t// largest code with non zero frequency\r\n\tvar node = elems;\t// next internal node of the tree\r\n\r\n    /* Construct the initial heap, with least frequent element in\r\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\r\n     * heap[0] is not used.\r\n     */\r\n\tzip_heap_len = 0;\r\n\tzip_heap_max = zip_HEAP_SIZE;\r\n\r\n\tfor (n = 0; n < elems; n++) {\r\n\t\tif (tree[n].fc !== 0) {\r\n\t\t\tzip_heap[++zip_heap_len] = max_code = n;\r\n\t\t\tzip_depth[n] = 0;\r\n\t\t} else\r\n\t\t\ttree[n].dl = 0;\r\n\t}\r\n\r\n    /* The pkzip format requires that at least one distance code exists,\r\n     * and that at least one bit should be sent even if there is only one\r\n     * possible code. So to avoid special checks later on we force at least\r\n     * two codes of non zero frequency.\r\n     */\r\n\twhile (zip_heap_len < 2) {\r\n\t\tvar xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\r\n\t\ttree[xnew].fc = 1;\r\n\t\tzip_depth[xnew] = 0;\r\n\t\tzip_opt_len--;\r\n\t\tif (stree !== null)\r\n\t\t\tzip_static_len -= stree[xnew].dl;\r\n\t\t// new is 0 or 1 so it does not have extra bits\r\n\t}\r\n\tdesc.max_code = max_code;\r\n\r\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\r\n     * establish sub-heaps of increasing lengths:\r\n     */\r\n\tfor (n = zip_heap_len >> 1; n >= 1; n--)\r\n\t\tzip_pqdownheap(tree, n);\r\n\r\n    /* Construct the Huffman tree by repeatedly combining the least two\r\n     * frequent nodes.\r\n     */\r\n\tdo {\r\n\t\tn = zip_heap[zip_SMALLEST];\r\n\t\tzip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\r\n\t\tzip_pqdownheap(tree, zip_SMALLEST);\r\n\r\n\t\tm = zip_heap[zip_SMALLEST];  // m = node of next least frequency\r\n\r\n\t\t// keep the nodes sorted by frequency\r\n\t\tzip_heap[--zip_heap_max] = n;\r\n\t\tzip_heap[--zip_heap_max] = m;\r\n\r\n\t\t// Create a new node father of n and m\r\n\t\ttree[node].fc = tree[n].fc + tree[m].fc;\r\n\t\t//\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\r\n\t\tif (zip_depth[n] > zip_depth[m] + 1)\r\n\t\t\tzip_depth[node] = zip_depth[n];\r\n\t\telse\r\n\t\t\tzip_depth[node] = zip_depth[m] + 1;\r\n\t\ttree[n].dl = tree[m].dl = node;\r\n\r\n\t\t// and insert the new node in the heap\r\n\t\tzip_heap[zip_SMALLEST] = node++;\r\n\t\tzip_pqdownheap(tree, zip_SMALLEST);\r\n\r\n\t} while (zip_heap_len >= 2);\r\n\r\n\tzip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\r\n\r\n    /* At this point, the fields freq and dad are set. We can now\r\n     * generate the bit lengths.\r\n     */\r\n\tzip_gen_bitlen(desc);\r\n\r\n\t// The field len is now set, we can generate the bit codes\r\n\tzip_gen_codes(tree, max_code);\r\n}\r\n\r\n/* ==========================================================================\r\n * Scan a literal or distance tree to determine the frequencies of the codes\r\n * in the bit length tree. Updates opt_len to take into account the repeat\r\n * counts. (The contribution of the bit length codes will be added later\r\n * during the construction of bl_tree.)\r\n */\r\nfunction zip_scan_tree(tree,// the tree to be scanned\r\n\tmax_code) {  // and its largest code of non zero frequency\r\n\tvar n;\t\t\t// iterates over all tree elements\r\n\tvar prevlen = -1;\t\t// last emitted length\r\n\tvar curlen;\t\t\t// length of current code\r\n\tvar nextlen = tree[0].dl;\t// length of next code\r\n\tvar count = 0;\t\t// repeat count of the current code\r\n\tvar max_count = 7;\t\t// max repeat count\r\n\tvar min_count = 4;\t\t// min repeat count\r\n\r\n\tif (nextlen === 0) {\r\n\t\tmax_count = 138;\r\n\t\tmin_count = 3;\r\n\t}\r\n\ttree[max_code + 1].dl = 0xffff; // guard\r\n\r\n\tfor (n = 0; n <= max_code; n++) {\r\n\t\tcurlen = nextlen;\r\n\t\tnextlen = tree[n + 1].dl;\r\n\t\tif (++count < max_count && curlen === nextlen)\r\n\t\t\tcontinue;\r\n\t\telse if (count < min_count)\r\n\t\t\tzip_bl_tree[curlen].fc += count;\r\n\t\telse if (curlen !== 0) {\r\n\t\t\tif (curlen !== prevlen)\r\n\t\t\t\tzip_bl_tree[curlen].fc++;\r\n\t\t\tzip_bl_tree[zip_REP_3_6].fc++;\r\n\t\t} else if (count <= 10)\r\n\t\t\tzip_bl_tree[zip_REPZ_3_10].fc++;\r\n\t\telse\r\n\t\t\tzip_bl_tree[zip_REPZ_11_138].fc++;\r\n\t\tcount = 0; prevlen = curlen;\r\n\t\tif (nextlen === 0) {\r\n\t\t\tmax_count = 138;\r\n\t\t\tmin_count = 3;\r\n\t\t} else if (curlen === nextlen) {\r\n\t\t\tmax_count = 6;\r\n\t\t\tmin_count = 3;\r\n\t\t} else {\r\n\t\t\tmax_count = 7;\r\n\t\t\tmin_count = 4;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Send a literal or distance tree in compressed form, using the codes in\r\n * bl_tree.\r\n */\r\nfunction zip_send_tree(tree, // the tree to be scanned\r\n\tmax_code) { // and its largest code of non zero frequency\r\n\tvar n;\t\t\t// iterates over all tree elements\r\n\tvar prevlen = -1;\t\t// last emitted length\r\n\tvar curlen;\t\t\t// length of current code\r\n\tvar nextlen = tree[0].dl;\t// length of next code\r\n\tvar count = 0;\t\t// repeat count of the current code\r\n\tvar max_count = 7;\t\t// max repeat count\r\n\tvar min_count = 4;\t\t// min repeat count\r\n\r\n\t/* tree[max_code+1].dl = -1; */  /* guard already set */\r\n\tif (nextlen === 0) {\r\n\t\tmax_count = 138;\r\n\t\tmin_count = 3;\r\n\t}\r\n\r\n\tfor (n = 0; n <= max_code; n++) {\r\n\t\tcurlen = nextlen;\r\n\t\tnextlen = tree[n + 1].dl;\r\n\t\tif (++count < max_count && curlen === nextlen) {\r\n\t\t\tcontinue;\r\n\t\t} else if (count < min_count) {\r\n\t\t\tdo { zip_SEND_CODE(curlen, zip_bl_tree); } while (--count !== 0);\r\n\t\t} else if (curlen !== 0) {\r\n\t\t\tif (curlen !== prevlen) {\r\n\t\t\t\tzip_SEND_CODE(curlen, zip_bl_tree);\r\n\t\t\t\tcount--;\r\n\t\t\t}\r\n\t\t\t// Assert(count >= 3 && count <= 6, \" 3_6?\");\r\n\t\t\tzip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\r\n\t\t\tzip_send_bits(count - 3, 2);\r\n\t\t} else if (count <= 10) {\r\n\t\t\tzip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\r\n\t\t\tzip_send_bits(count - 3, 3);\r\n\t\t} else {\r\n\t\t\tzip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\r\n\t\t\tzip_send_bits(count - 11, 7);\r\n\t\t}\r\n\t\tcount = 0;\r\n\t\tprevlen = curlen;\r\n\t\tif (nextlen === 0) {\r\n\t\t\tmax_count = 138;\r\n\t\t\tmin_count = 3;\r\n\t\t} else if (curlen === nextlen) {\r\n\t\t\tmax_count = 6;\r\n\t\t\tmin_count = 3;\r\n\t\t} else {\r\n\t\t\tmax_count = 7;\r\n\t\t\tmin_count = 4;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Construct the Huffman tree for the bit lengths and return the index in\r\n * bl_order of the last bit length code to send.\r\n */\r\nfunction zip_build_bl_tree() {\r\n\tvar max_blindex;  // index of last bit length code of non zero freq\r\n\r\n\t// Determine the bit length frequencies for literal and distance trees\r\n\tzip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\r\n\tzip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\r\n\r\n\t// Build the bit length tree:\r\n\tzip_build_tree(zip_bl_desc);\r\n    /* opt_len now includes the length of the tree representations, except\r\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\r\n     */\r\n\r\n    /* Determine the number of bit length codes to send. The pkzip format\r\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\r\n     * 3 but the actual value used is 4.)\r\n     */\r\n\tfor (max_blindex = zip_BL_CODES - 1; max_blindex >= 3; max_blindex--) {\r\n\t\tif (zip_bl_tree[zip_bl_order[max_blindex]].dl !== 0) break;\r\n\t}\r\n\t/* Update opt_len to include the bit length tree and counts */\r\n\tzip_opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\r\n\t//    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\r\n\t//\t    encoder->opt_len, encoder->static_len));\r\n\r\n\treturn max_blindex;\r\n}\r\n\r\n/* ==========================================================================\r\n * Send the header for a block using dynamic Huffman trees: the counts, the\r\n * lengths of the bit length codes, the literal tree and the distance tree.\r\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\r\n */\r\nfunction zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\r\n\tvar rank; // index in bl_order\r\n\r\n\t//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\r\n\t//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\r\n\t//\t    \"too many codes\");\r\n\t//    Tracev((stderr, \"\\nbl counts: \"));\r\n\tzip_send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\r\n\tzip_send_bits(dcodes - 1, 5);\r\n\tzip_send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\r\n\tfor (rank = 0; rank < blcodes; rank++) {\r\n\t\t//      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\r\n\t\tzip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\r\n\t}\r\n\r\n\t// send the literal tree\r\n\tzip_send_tree(zip_dyn_ltree, lcodes - 1);\r\n\r\n\t// send the distance tree\r\n\tzip_send_tree(zip_dyn_dtree, dcodes - 1);\r\n}\r\n\r\n/* ==========================================================================\r\n * Determine the best encoding for the current block: dynamic trees, static\r\n * trees or store, and output the encoded block to the zip file.\r\n */\r\nfunction zip_flush_block(eof) { // true if this is the last block for a file\r\n\tvar opt_lenb, static_lenb; // opt_len and static_len in bytes\r\n\tvar max_blindex;\t// index of last bit length code of non zero freq\r\n\tvar stored_len;\t// length of input block\r\n\r\n\tstored_len = zip_strstart - zip_block_start;\r\n\tzip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\r\n\r\n\t// Construct the literal and distance trees\r\n\tzip_build_tree(zip_l_desc);\r\n\t//    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\r\n\t//\t    encoder->opt_len, encoder->static_len));\r\n\r\n\tzip_build_tree(zip_d_desc);\r\n\t//    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\r\n\t//\t    encoder->opt_len, encoder->static_len));\r\n    /* At this point, opt_len and static_len are the total bit lengths of\r\n     * the compressed block data, excluding the tree representations.\r\n     */\r\n\r\n    /* Build the bit length tree for the above two trees, and get the index\r\n     * in bl_order of the last bit length code to send.\r\n     */\r\n\tmax_blindex = zip_build_bl_tree();\r\n\r\n\t// Determine the best encoding. Compute first the block length in bytes\r\n\topt_lenb = (zip_opt_len + 3 + 7) >> 3;\r\n\tstatic_lenb = (zip_static_len + 3 + 7) >> 3;\r\n\r\n\t//    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\r\n\t//\t   opt_lenb, encoder->opt_len,\r\n\t//\t   static_lenb, encoder->static_len, stored_len,\r\n\t//\t   encoder->last_lit, encoder->last_dist));\r\n\r\n\tif (static_lenb <= opt_lenb)\r\n\t\topt_lenb = static_lenb;\r\n\tif (stored_len + 4 <= opt_lenb // 4: two words for the lengths\r\n\t\t&& zip_block_start >= 0) {\r\n\t\tvar i;\r\n\r\n\t\t/* The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.\r\n\t\t * Otherwise we can't have processed more than WSIZE input bytes since\r\n\t\t * the last block flush, because compression would have been\r\n\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\r\n\t\t * transform a block into a stored block.\r\n\t\t */\r\n\t\tzip_send_bits((zip_STORED_BLOCK << 1) + eof, 3);  /* send block type */\r\n\t\tzip_bi_windup();\t\t /* align on byte boundary */\r\n\t\tzip_put_short(stored_len);\r\n\t\tzip_put_short(~stored_len);\r\n\r\n\t\t// copy block\r\n\t\t/*\r\n\t\t\t  p = &window[block_start];\r\n\t\t\t  for(i = 0; i < stored_len; i++)\r\n\t\t\tput_byte(p[i]);\r\n\t\t*/\r\n\t\tfor (i = 0; i < stored_len; i++)\r\n\t\t\tzip_put_byte(zip_window[zip_block_start + i]);\r\n\r\n\t} else if (static_lenb === opt_lenb) {\r\n\t\tzip_send_bits((zip_STATIC_TREES << 1) + eof, 3);\r\n\t\tzip_compress_block(zip_static_ltree, zip_static_dtree);\r\n\t} else {\r\n\t\tzip_send_bits((zip_DYN_TREES << 1) + eof, 3);\r\n\t\tzip_send_all_trees(zip_l_desc.max_code + 1,\r\n\t\t\tzip_d_desc.max_code + 1,\r\n\t\t\tmax_blindex + 1);\r\n\t\tzip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\r\n\t}\r\n\r\n\tzip_init_block();\r\n\r\n\tif (eof !== 0)\r\n\t\tzip_bi_windup();\r\n}\r\n\r\n/* ==========================================================================\r\n * Save the match info and tally the frequency counts. Return true if\r\n * the current block must be flushed.\r\n */\r\nfunction zip_ct_tally(\r\n\tdist, // distance of matched string\r\n\tlc) { // match length-MIN_MATCH or unmatched char (if dist==0)\r\n\tzip_l_buf[zip_last_lit++] = lc;\r\n\tif (dist === 0) {\r\n\t\t// lc is the unmatched char\r\n\t\tzip_dyn_ltree[lc].fc++;\r\n\t} else {\r\n\t\t// Here, lc is the match length - MIN_MATCH\r\n\t\tdist--;\t\t    // dist = match distance - 1\r\n\t\t//      Assert((ush)dist < (ush)MAX_DIST &&\r\n\t\t//\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\r\n\t\t//\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\r\n\r\n\t\tzip_dyn_ltree[zip_length_code[lc] + zip_LITERALS + 1].fc++;\r\n\t\tzip_dyn_dtree[zip_D_CODE(dist)].fc++;\r\n\r\n\t\tzip_d_buf[zip_last_dist++] = dist;\r\n\t\tzip_flags |= zip_flag_bit;\r\n\t}\r\n\tzip_flag_bit <<= 1;\r\n\r\n\t// Output the flags if they fill a byte\r\n\tif ((zip_last_lit & 7) === 0) {\r\n\t\tzip_flag_buf[zip_last_flags++] = zip_flags;\r\n\t\tzip_flags = 0;\r\n\t\tzip_flag_bit = 1;\r\n\t}\r\n\t// Try to guess if it is profitable to stop the current block here\r\n\tif (zip_compr_level > 2 && (zip_last_lit & 0xfff) === 0) {\r\n\t\t// Compute an upper bound for the compressed length\r\n\t\tvar out_length = zip_last_lit * 8;\r\n\t\tvar in_length = zip_strstart - zip_block_start;\r\n\t\tvar dcode;\r\n\r\n\t\tfor (dcode = 0; dcode < zip_D_CODES; dcode++) {\r\n\t\t\tout_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\r\n\t\t}\r\n\t\tout_length >>= 3;\r\n\t\t//      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\r\n\t\t//\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\r\n\t\t//\t     100L - out_length*100L/in_length));\r\n\t\tif (zip_last_dist < parseInt(zip_last_lit / 2) &&\r\n\t\t\tout_length < parseInt(in_length / 2))\r\n\t\t\treturn true;\r\n\t}\r\n\treturn (zip_last_lit === zip_LIT_BUFSIZE - 1 ||\r\n\t\tzip_last_dist === zip_DIST_BUFSIZE);\r\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\r\n     * on 16 bit machines and because stored blocks are restricted to\r\n     * 64K-1 bytes.\r\n     */\r\n}\r\n\r\n/* ==========================================================================\r\n * Send the block data compressed using the given Huffman trees\r\n */\r\nfunction zip_compress_block(\r\n\tltree,\t// literal tree\r\n\tdtree) {\t// distance tree\r\n\tvar dist;\t\t// distance of matched string\r\n\tvar lc;\t\t// match length or unmatched char (if dist === 0)\r\n\tvar lx = 0;\t\t// running index in l_buf\r\n\tvar dx = 0;\t\t// running index in d_buf\r\n\tvar fx = 0;\t\t// running index in flag_buf\r\n\tvar flag = 0;\t// current flags\r\n\tvar code;\t\t// the code to send\r\n\tvar extra;\t\t// number of extra bits to send\r\n\r\n\tif (zip_last_lit !== 0) do {\r\n\t\tif ((lx & 7) === 0)\r\n\t\t\tflag = zip_flag_buf[fx++];\r\n\t\tlc = zip_l_buf[lx++] & 0xff;\r\n\t\tif ((flag & 1) === 0) {\r\n\t\t\tzip_SEND_CODE(lc, ltree); /* send a literal byte */\r\n\t\t\t//\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\r\n\t\t} else {\r\n\t\t\t// Here, lc is the match length - MIN_MATCH\r\n\t\t\tcode = zip_length_code[lc];\r\n\t\t\tzip_SEND_CODE(code + zip_LITERALS + 1, ltree); // send the length code\r\n\t\t\textra = zip_extra_lbits[code];\r\n\t\t\tif (extra !== 0) {\r\n\t\t\t\tlc -= zip_base_length[code];\r\n\t\t\t\tzip_send_bits(lc, extra); // send the extra length bits\r\n\t\t\t}\r\n\t\t\tdist = zip_d_buf[dx++];\r\n\t\t\t// Here, dist is the match distance - 1\r\n\t\t\tcode = zip_D_CODE(dist);\r\n\t\t\t//\tAssert (code < D_CODES, \"bad d_code\");\r\n\r\n\t\t\tzip_SEND_CODE(code, dtree);\t  // send the distance code\r\n\t\t\textra = zip_extra_dbits[code];\r\n\t\t\tif (extra !== 0) {\r\n\t\t\t\tdist -= zip_base_dist[code];\r\n\t\t\t\tzip_send_bits(dist, extra);   // send the extra distance bits\r\n\t\t\t}\r\n\t\t} // literal or match pair ?\r\n\t\tflag >>= 1;\r\n\t} while (lx < zip_last_lit);\r\n\r\n\tzip_SEND_CODE(zip_END_BLOCK, ltree);\r\n}\r\n\r\n/* ==========================================================================\r\n * Send a value on a given number of bits.\r\n * IN assertion: length <= 16 and value fits in length bits.\r\n */\r\nvar zip_Buf_size = 16; // bit size of bi_buf\r\nfunction zip_send_bits(\r\n\tvalue,\t// value to send\r\n\tlength) {\t// number of bits\r\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\r\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\r\n     * unused bits in value.\r\n     */\r\n\tif (zip_bi_valid > zip_Buf_size - length) {\r\n\t\tzip_bi_buf |= (value << zip_bi_valid);\r\n\t\tzip_put_short(zip_bi_buf);\r\n\t\tzip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\r\n\t\tzip_bi_valid += length - zip_Buf_size;\r\n\t} else {\r\n\t\tzip_bi_buf |= value << zip_bi_valid;\r\n\t\tzip_bi_valid += length;\r\n\t}\r\n}\r\n\r\n/* ==========================================================================\r\n * Reverse the first len bits of a code, using straightforward code (a faster\r\n * method would use a table)\r\n * IN assertion: 1 <= len <= 15\r\n */\r\nfunction zip_bi_reverse(\r\n\tcode,\t// the value to invert\r\n\tlen) {\t// its bit length\r\n\tvar res = 0;\r\n\tdo {\r\n\t\tres |= code & 1;\r\n\t\tcode >>= 1;\r\n\t\tres <<= 1;\r\n\t} while (--len > 0);\r\n\treturn res >> 1;\r\n}\r\n\r\n/* ==========================================================================\r\n * Write out any remaining bits in an incomplete byte.\r\n */\r\nfunction zip_bi_windup() {\r\n\tif (zip_bi_valid > 8) {\r\n\t\tzip_put_short(zip_bi_buf);\r\n\t} else if (zip_bi_valid > 0) {\r\n\t\tzip_put_byte(zip_bi_buf);\r\n\t}\r\n\tzip_bi_buf = 0;\r\n\tzip_bi_valid = 0;\r\n}\r\n\r\nfunction zip_qoutbuf() {\r\n\tif (zip_outcnt !== 0) {\r\n\t\tvar q, i;\r\n\t\tq = zip_new_queue();\r\n\t\tif (zip_qhead === null)\r\n\t\t\tzip_qhead = zip_qtail = q;\r\n\t\telse\r\n\t\t\tzip_qtail = zip_qtail.next = q;\r\n\t\tq.len = zip_outcnt - zip_outoff;\r\n\t\t//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\r\n\t\tfor (i = 0; i < q.len; i++)\r\n\t\t\tq.ptr[i] = zip_outbuf[zip_outoff + i];\r\n\t\tzip_outcnt = zip_outoff = 0;\r\n\t}\r\n}\r\n\r\nexport function codify(word) {\r\n\treturn new Promise(function(resolve, reject) {\r\n\t\tvar zip = zip_deflate(word, 9);\r\n\t\tresolve(encode64(zip));\r\n\t});\r\n}\r\n\r\nfunction zip_deflate(str, level) {\r\n\tvar out, buff;\r\n\tvar i, j;\r\n\r\n\tzip_deflate_data = str;\r\n\tzip_deflate_pos = 0;\r\n\tif (typeof level === \"undefined\")\r\n\t\tlevel = zip_DEFAULT_LEVEL;\r\n\tzip_deflate_start(level);\r\n\r\n\tbuff = new Array(1024);\r\n\tout = \"\";\r\n\twhile ((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\r\n\t\tfor (j = 0; j < i; j++)\r\n\t\t\tout += String.fromCharCode(buff[j]);\r\n\t}\r\n\tzip_deflate_data = null; // G.C.\r\n\treturn out;\r\n}\r\n\r\nfunction encode64(data) {\r\n\tvar r = \"\";\r\n\tfor (let i = 0; i < data.length; i += 3) {\r\n\t\tif (i + 2 === data.length) {\r\n\t\t\tr += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\r\n\t\t} else if (i + 1 === data.length) {\r\n\t\t\tr += append3bytes(data.charCodeAt(i), 0, 0);\r\n\t\t} else {\r\n\t\t\tr += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), data.charCodeAt(i + 2));\r\n\t\t}\r\n\t}\r\n\treturn r;\r\n}\r\n\r\nfunction append3bytes(b1, b2, b3) {\r\n\tvar c1 = b1 >> 2;\r\n\tvar c2 = ((b1 & 0x3) << 4) | (b2 >> 4);\r\n\tvar c3 = ((b2 & 0xF) << 2) | (b3 >> 6);\r\n\tvar c4 = b3 & 0x3F;\r\n\tvar r = \"\";\r\n\tr += encode6bit(c1 & 0x3F);\r\n\tr += encode6bit(c2 & 0x3F);\r\n\tr += encode6bit(c3 & 0x3F);\r\n\tr += encode6bit(c4 & 0x3F);\r\n\treturn r;\r\n}\r\n\r\nfunction encode6bit(b) {\r\n\tif (b < 10) {\r\n\t\treturn String.fromCharCode(48 + b);\r\n\t}\r\n\tb -= 10;\r\n\tif (b < 26) {\r\n\t\treturn String.fromCharCode(65 + b);\r\n\t}\r\n\tb -= 26;\r\n\tif (b < 26) {\r\n\t\treturn String.fromCharCode(97 + b);\r\n\t}\r\n\tb -= 26;\r\n\tif (b === 0) {\r\n\t\treturn '-';\r\n\t}\r\n\tif (b === 1) {\r\n\t\treturn '_';\r\n\t}\r\n\treturn '?';\r\n}","import React from 'react';\r\nimport uml from '../../assets/home_uml.png';\r\nimport { codify } from '../../assets/deflate';\r\n\r\nconst Home = () => {\r\n\r\n    function send(e) {\r\n        let text = document.querySelector('#text-uml').value;\r\n        text = unescape(encodeURIComponent(text));\r\n        let sendBtn = e.target;\r\n        sendBtn.classList.add('is-loading');\r\n        codify(text).then(data => {\r\n            document.querySelector('#img-uml').src = `https://www.plantuml.com/plantuml/img/${data}`;\r\n            setTimeout(()=> {\r\n                sendBtn.classList.remove('is-loading');\r\n            }, 500)\r\n        })\r\n    }\r\n\r\n    return (\r\n        <div className=\"container is-fluid is-flex body-container\">\r\n            <div className=\"text\">\r\n                <textarea defaultValue=\"Rebeca -> Joe : Hi\" id=\"text-uml\" spellCheck=\"false\" />\r\n                <button className=\"button is-action\" onClick={send}>Send</button>\r\n            </div>\r\n            <div className=\"image\">\r\n                <img src={uml} alt=\"uml-graph\" id=\"img-uml\" />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Home;\r\n","import React from 'react';\r\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faHashtag, faAngleRight } from '@fortawesome/free-solid-svg-icons';\r\nimport imgUml1 from '../../assets/ab_uml1.png';\r\n\r\nconst About = () => {\r\n    \r\n    let uml1 = `@startuml\r\n:Hello world;\r\n:This is \r\nthe **beggining**;\r\n@enduml`;\r\n\r\n    return (\r\n        <div className=\"container is-fluid body-container\">\r\n            <section className=\"usage\">\r\n                <div className=\"ab-title big\">\r\n                    <FontAwesomeIcon icon={faHashtag} />\r\n                    <h1 className=\"text text-b\">Usage</h1>\r\n                </div>\r\n                <h1>All you need to do is write your UML text in the box and send, then you will get your diagram. For example this text:</h1>\r\n                <pre>{uml1}</pre>\r\n                <h1>Will be transformed in this image:</h1>\r\n                <img src={imgUml1} alt=\"uml1\"/>\r\n                <h1 className=\"has-text-weight-bold\t\">To download right click and save as...</h1>\r\n            </section>\r\n            <section className=\"demo mt-1\">\r\n                <div className=\"ab-title big\">\r\n                    <FontAwesomeIcon icon={faHashtag} />\r\n                    <h1 className=\"text text-b\">Diagrams</h1>\r\n                </div>\r\n                <h1>This web uses the UML language from plantUML:</h1>\r\n                <div className=\"ab-title lit mt-1\">\r\n                    <FontAwesomeIcon icon={faAngleRight} />\r\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/sequence-diagram\">Sequence</a>\r\n                </div>\r\n                <div className=\"ab-title lit mt-1\">\r\n                    <FontAwesomeIcon icon={faAngleRight} />\r\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/activity-diagram-beta\">Activity</a>\r\n                </div>\r\n                <div className=\"ab-title lit mt-1\">\r\n                    <FontAwesomeIcon icon={faAngleRight} />\r\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/use-case-diagram\">Usecase</a>\r\n                </div>\r\n                <div className=\"ab-title lit mt-1\">\r\n                    <FontAwesomeIcon icon={faAngleRight} />\r\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/class-diagram\">Class</a>\r\n                </div>\r\n                <div className=\"ab-title lit mt-1\">\r\n                    <FontAwesomeIcon icon={faAngleRight} />\r\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/\">Many more...</a>\r\n                </div>\r\n            </section>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default About;\r\n","import React from 'react';\r\nimport './App.scss';\r\nimport {\r\n  BrowserRouter as Router,\r\n  Switch,\r\n  Route\r\n} from 'react-router-dom';\r\nimport Nav from './components/Nav/Nav';\r\nimport Home from './components/Home/Home';\r\nimport About from './components/About/About';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Router basename=\"/quickplantuml/\">\r\n        <Nav />\r\n        <Switch>\r\n          <Route path=\"/\" exact component={Home} />\r\n          <Route path=\"/about\" exact component={About} />\r\n        </Switch>\r\n      </Router>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.scss';\r\nimport 'bulma/css/bulma.min.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}