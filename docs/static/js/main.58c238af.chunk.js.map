{"version":3,"sources":["assets/qpl_logo.svg","assets/home_uml.png","assets/ab_uml1.png","components/Nav/Nav.js","assets/deflate.js","components/Home/Home.js","components/About/About.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Nav","document","addEventListener","$navbarBurgers","Array","prototype","slice","call","querySelectorAll","length","forEach","el","target","dataset","$target","getElementById","classList","toggle","className","role","aria-label","src","logo","alt","aria-expanded","data-target","aria-hidden","id","to","href","zip_free_queue","zip_qhead","zip_qtail","zip_initflag","zip_outcnt","zip_outoff","zip_complete","zip_window","zip_d_buf","zip_l_buf","zip_prev","zip_bi_buf","zip_bi_valid","zip_block_start","zip_ins_h","zip_hash_head","zip_prev_match","zip_match_available","zip_match_length","zip_prev_length","zip_strstart","zip_match_start","zip_eofile","zip_lookahead","zip_max_chain_length","zip_max_lazy_match","zip_compr_level","zip_good_match","zip_dyn_ltree","zip_dyn_dtree","zip_static_ltree","zip_static_dtree","zip_bl_tree","zip_l_desc","zip_d_desc","zip_bl_desc","zip_bl_count","zip_heap","zip_heap_len","zip_heap_max","zip_depth","zip_length_code","zip_dist_code","zip_base_length","zip_base_dist","zip_flag_buf","zip_last_lit","zip_last_dist","zip_last_flags","zip_flags","zip_flag_bit","zip_opt_len","zip_static_len","zip_deflate_data","zip_deflate_pos","zip_H_SHIFT","parseInt","zip_outbuf","zip_extra_lbits","zip_extra_dbits","zip_extra_blbits","zip_bl_order","zip_configuration_table","zip_DeflateConfiguration","zip_DeflateCT","this","fc","dl","zip_DeflateTreeDesc","dyn_tree","static_tree","extra_bits","extra_base","elems","max_length","max_code","a","b","c","d","good_length","max_lazy","nice_length","max_chain","zip_DeflateBuffer","next","len","ptr","off","zip_reuse_queue","p","zip_head1","i","zip_head2","val","zip_put_byte","q","zip_new_queue","zip_qoutbuf","zip_put_short","w","zip_OUTBUFSIZ","zip_INSERT_STRING","zip_HASH_SIZE","zip_WSIZE","zip_SEND_CODE","tree","zip_send_bits","zip_D_CODE","dist","zip_SMALLER","n","m","zip_read_buff","buff","offset","charCodeAt","zip_longest_match","cur_match","matchp","chain_length","scanp","best_len","limit","strendp","scan_end1","scan_end","zip_fill_window","more","zip_init_deflate","bits","code","zip_LITERALS","zip_LENGTH_CODES","zip_gen_codes","zip_L_CODES","zip_bi_reverse","zip_init_block","zip_ct_init","j","zip_MAX_MATCH","zip_MIN_MATCH","zip_lm_init","zip_deflate_internal","buff_size","zip_qcopy","flush","zip_ct_tally","zip_flush_block","zip_deflate_fast","zip_deflate_better","zip_pqdownheap","k","v","next_code","zip_MAX_BITS","zip_build_tree","desc","stree","node","xnew","h","xbits","f","extra","base","overflow","zip_gen_bitlen","zip_scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","zip_send_tree","eof","opt_lenb","static_lenb","max_blindex","stored_len","zip_BL_CODES","zip_build_bl_tree","zip_bi_windup","zip_compress_block","lcodes","dcodes","blcodes","rank","zip_send_all_trees","lc","dcode","out_length","in_length","zip_LIT_BUFSIZE","ltree","dtree","lx","dx","fx","flag","value","res","codify","word","Promise","resolve","reject","data","r","append3bytes","encode64","str","level","out","zip_INBUFSIZ","zip_deflate_start","String","fromCharCode","zip_deflate","b1","b2","b3","c2","c3","c4","encode6bit","Home","defaultValue","spellCheck","onClick","e","text","querySelector","unescape","encodeURIComponent","sendBtn","add","then","setTimeout","remove","uml","About","icon","faHashtag","imgUml1","faAngleRight","App","path","exact","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.58c238af.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/qpl_logo.b2ebc6b9.svg\";","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","import React from 'react';\nimport { Link } from 'react-router-dom';\nimport logo from '../../assets/qpl_logo.svg';\n\nconst Nav = () => {\n    document.addEventListener('DOMContentLoaded', () => {\n        // Get all \"navbar-burger\" elements\n        const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);\n        // Check if there are any navbar burgers\n        if ($navbarBurgers.length > 0) {\n            // Add a click event on each of them\n            $navbarBurgers.forEach(el => {\n                el.addEventListener('click', () => {\n                    // Get the target from the \"data-target\" attribute\n                    const target = el.dataset.target;\n                    const $target = document.getElementById(target);\n                    // Toggle the \"is-active\" class on both the \"navbar-burger\" and the \"navbar-menu\"\n                    el.classList.toggle('is-active');\n                    $target.classList.toggle('is-active');\n\n                });\n            });\n        }\n\n    });\n\n    return (\n        <div className=\"container is-fluid\">\n            <nav className=\"navbar\" role=\"navigation\" aria-label=\"main navigation\">\n                <div className=\"navbar-brand\">\n                    <img src={logo} alt=\"logo\" className=\"main-logo\" />\n\n                    <a role=\"button\" className=\"navbar-burger burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"main-links\">\n                        <span aria-hidden=\"true\"></span>\n                        <span aria-hidden=\"true\"></span>\n                        <span aria-hidden=\"true\"></span>\n                    </a>\n                </div>\n\n                <div id=\"main-links\" className=\"navbar-menu\">\n                    <div className=\"navbar-end\">\n                        <div className=\"navbar-item\">\n                            <Link className=\"bold main\" to=\"/\">Home</Link>\n                        </div>\n                        <div className=\"navbar-item\">\n                            <Link className=\"bold main\" to=\"/about\">About</Link>\n                        </div>\n                        <div className=\"navbar-item\">\n                            <a className=\"bold main\" href=\"https://github.com/alexpierola/quickplantuml\">View on GitHub</a>\n                        </div>\n                    </div>\n                </div>\n            </nav>\n        </div>\n    );\n}\n\nexport default Nav;\n","/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0.1\n * LastModified: Dec 25 1999\n */\n\n/* Interface:\n * data = zip_deflate(src);\n */\n\n/* constant parameters */\nvar zip_WSIZE = 32768;\t\t// Sliding Window size\nvar zip_STORED_BLOCK = 0;\nvar zip_STATIC_TREES = 1;\nvar zip_DYN_TREES = 2;\n\n/* for deflate */\nvar zip_DEFAULT_LEVEL = 6;\nvar zip_FULL_SEARCH = true;\nvar zip_INBUFSIZ = 32768;\t// Input buffer size\nvar zip_INBUF_EXTRA = 64;\t// Extra buffer\nvar zip_OUTBUFSIZ = 1024 * 8;\nvar zip_window_size = 2 * zip_WSIZE;\nvar zip_MIN_MATCH = 3;\nvar zip_MAX_MATCH = 258;\nvar zip_BITS = 16;\n// for SMALL_MEM\nvar zip_LIT_BUFSIZE = 0x2000;\nvar zip_HASH_BITS = 13;\n// for MEDIUM_MEM\n// var zip_LIT_BUFSIZE = 0x4000;\n// var zip_HASH_BITS = 14;\n// for BIG_MEM\n// var zip_LIT_BUFSIZE = 0x8000;\n// var zip_HASH_BITS = 15;\nif (zip_LIT_BUFSIZE > zip_INBUFSIZ)\n\talert(\"error: zip_INBUFSIZ is too small\");\nif ((zip_WSIZE << 1) > (1 << zip_BITS))\n\talert(\"error: zip_WSIZE is too large\");\nif (zip_HASH_BITS > zip_BITS - 1)\n\talert(\"error: zip_HASH_BITS is too large\");\nif (zip_HASH_BITS < 8 || zip_MAX_MATCH !== 258)\n\talert(\"error: Code too clever\");\nvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\nvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\nvar zip_HASH_MASK = zip_HASH_SIZE - 1;\nvar zip_WMASK = zip_WSIZE - 1;\nvar zip_NIL = 0; // Tail of hash chains\nvar zip_TOO_FAR = 4096;\nvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\nvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\nvar zip_SMALLEST = 1;\nvar zip_MAX_BITS = 15;\nvar zip_MAX_BL_BITS = 7;\nvar zip_LENGTH_CODES = 29;\nvar zip_LITERALS = 256;\nvar zip_END_BLOCK = 256;\nvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\nvar zip_D_CODES = 30;\nvar zip_BL_CODES = 19;\nvar zip_REP_3_6 = 16;\nvar zip_REPZ_3_10 = 17;\nvar zip_REPZ_11_138 = 18;\nvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\nvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\n\tzip_MIN_MATCH);\n\n/* variables */\nvar zip_free_queue;\nvar zip_qhead, zip_qtail;\nvar zip_initflag;\nvar zip_outbuf = null;\nvar zip_outcnt, zip_outoff;\nvar zip_complete;\nvar zip_window;\nvar zip_d_buf;\nvar zip_l_buf;\nvar zip_prev;\nvar zip_bi_buf;\nvar zip_bi_valid;\nvar zip_block_start;\nvar zip_ins_h;\nvar zip_hash_head;\nvar zip_prev_match;\nvar zip_match_available;\nvar zip_match_length;\nvar zip_prev_length;\nvar zip_strstart;\nvar zip_match_start;\nvar zip_eofile;\nvar zip_lookahead;\nvar zip_max_chain_length;\nvar zip_max_lazy_match;\nvar zip_compr_level;\nvar zip_good_match;\nvar zip_nice_match;\nvar zip_dyn_ltree;\nvar zip_dyn_dtree;\nvar zip_static_ltree;\nvar zip_static_dtree;\nvar zip_bl_tree;\nvar zip_l_desc;\nvar zip_d_desc;\nvar zip_bl_desc;\nvar zip_bl_count;\nvar zip_heap;\nvar zip_heap_len;\nvar zip_heap_max;\nvar zip_depth;\nvar zip_length_code;\nvar zip_dist_code;\nvar zip_base_length;\nvar zip_base_dist;\nvar zip_flag_buf;\nvar zip_last_lit;\nvar zip_last_dist;\nvar zip_last_flags;\nvar zip_flags;\nvar zip_flag_bit;\nvar zip_opt_len;\nvar zip_static_len;\nvar zip_deflate_data;\nvar zip_deflate_pos;\n\n/* constant tables */\nvar zip_extra_lbits = [\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\nvar zip_extra_dbits = [\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\nvar zip_extra_blbits = [\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\nvar zip_bl_order = [\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\nvar zip_configuration_table = [\n\tnew zip_DeflateConfiguration(0, 0, 0, 0),\n\tnew zip_DeflateConfiguration(4, 4, 8, 4),\n\tnew zip_DeflateConfiguration(4, 5, 16, 8),\n\tnew zip_DeflateConfiguration(4, 6, 32, 32),\n\tnew zip_DeflateConfiguration(4, 4, 16, 16),\n\tnew zip_DeflateConfiguration(8, 16, 32, 32),\n\tnew zip_DeflateConfiguration(8, 16, 128, 128),\n\tnew zip_DeflateConfiguration(8, 32, 128, 256),\n\tnew zip_DeflateConfiguration(32, 128, 258, 1024),\n\tnew zip_DeflateConfiguration(32, 258, 258, 4096)];\n\n/* objects (deflate) */\n\nfunction zip_DeflateCT() {\n\tthis.fc = 0; // frequency count or bit string\n\tthis.dl = 0; // father node in Huffman tree or length of bit string\n}\n\nfunction zip_DeflateTreeDesc() {\n\tthis.dyn_tree = null;\t// the dynamic tree\n\tthis.static_tree = null;\t// corresponding static tree or NULL\n\tthis.extra_bits = null;\t// extra bits for each code or NULL\n\tthis.extra_base = 0;\t// base index for extra_bits\n\tthis.elems = 0;\t\t// max number of elements in the tree\n\tthis.max_length = 0;\t// max bit length for the codes\n\tthis.max_code = 0;\t\t// largest code with non zero frequency\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction zip_DeflateConfiguration(a, b, c, d) {\n\tthis.good_length = a; // reduce lazy search above this match length\n\tthis.max_lazy = b;    // do not perform lazy search above this match length\n\tthis.nice_length = c; // quit search above this match length\n\tthis.max_chain = d;\n}\n\nfunction zip_DeflateBuffer() {\n\tthis.next = null;\n\tthis.len = 0;\n\tthis.ptr = new Array(zip_OUTBUFSIZ);\n\tthis.off = 0;\n}\n\n/* routines (deflate) */\n\nfunction zip_deflate_start(level) {\n\tvar i;\n\n\tif (!level)\n\t\tlevel = zip_DEFAULT_LEVEL;\n\telse if (level < 1)\n\t\tlevel = 1;\n\telse if (level > 9)\n\t\tlevel = 9;\n\n\tzip_compr_level = level;\n\tzip_initflag = false;\n\tzip_eofile = false;\n\tif (zip_outbuf !== null)\n\t\treturn;\n\n\tzip_free_queue = zip_qhead = zip_qtail = null;\n\tzip_outbuf = new Array(zip_OUTBUFSIZ);\n\tzip_window = new Array(zip_window_size);\n\tzip_d_buf = new Array(zip_DIST_BUFSIZE);\n\tzip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\n\tzip_prev = new Array(1 << zip_BITS);\n\tzip_dyn_ltree = new Array(zip_HEAP_SIZE);\n\tfor (i = 0; i < zip_HEAP_SIZE; i++)\n\t\tzip_dyn_ltree[i] = new zip_DeflateCT();\n\tzip_dyn_dtree = new Array(2 * zip_D_CODES + 1);\n\tfor (i = 0; i < 2 * zip_D_CODES + 1; i++)\n\t\tzip_dyn_dtree[i] = new zip_DeflateCT();\n\tzip_static_ltree = new Array(zip_L_CODES + 2);\n\tfor (i = 0; i < zip_L_CODES + 2; i++)\n\t\tzip_static_ltree[i] = new zip_DeflateCT();\n\tzip_static_dtree = new Array(zip_D_CODES);\n\tfor (i = 0; i < zip_D_CODES; i++)\n\t\tzip_static_dtree[i] = new zip_DeflateCT();\n\tzip_bl_tree = new Array(2 * zip_BL_CODES + 1);\n\tfor (i = 0; i < 2 * zip_BL_CODES + 1; i++)\n\t\tzip_bl_tree[i] = new zip_DeflateCT();\n\tzip_l_desc = new zip_DeflateTreeDesc();\n\tzip_d_desc = new zip_DeflateTreeDesc();\n\tzip_bl_desc = new zip_DeflateTreeDesc();\n\tzip_bl_count = new Array(zip_MAX_BITS + 1);\n\tzip_heap = new Array(2 * zip_L_CODES + 1);\n\tzip_depth = new Array(2 * zip_L_CODES + 1);\n\tzip_length_code = new Array(zip_MAX_MATCH - zip_MIN_MATCH + 1);\n\tzip_dist_code = new Array(512);\n\tzip_base_length = new Array(zip_LENGTH_CODES);\n\tzip_base_dist = new Array(zip_D_CODES);\n\tzip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\n}\n\nfunction zip_reuse_queue(p) {\n\tp.next = zip_free_queue;\n\tzip_free_queue = p;\n}\n\nfunction zip_new_queue() {\n\tvar p;\n\n\tif (zip_free_queue !== null) {\n\t\tp = zip_free_queue;\n\t\tzip_free_queue = zip_free_queue.next;\n\t}\n\telse\n\t\tp = new zip_DeflateBuffer();\n\tp.next = null;\n\tp.len = p.off = 0;\n\n\treturn p;\n}\n\nfunction zip_head1(i) {\n\treturn zip_prev[zip_WSIZE + i];\n}\n\nfunction zip_head2(i, val) {\n\treturn zip_prev[zip_WSIZE + i] = val;\n}\n\n/* put_byte is used for the compressed output, put_ubyte for the\n * uncompressed output. However unlzw() uses window for its\n * suffix table instead of its output buffer, so it does not use put_ubyte\n * (to be cleaned up).\n */\nfunction zip_put_byte(c) {\n\tzip_outbuf[zip_outoff + zip_outcnt++] = c;\n\tif (zip_outoff + zip_outcnt === zip_OUTBUFSIZ)\n\t\tzip_qoutbuf();\n}\n\n/* Output a 16 bit value, lsb first */\nfunction zip_put_short(w) {\n\tw &= 0xffff;\n\tif (zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\n\t\tzip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\n\t\tzip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\n\t} else {\n\t\tzip_put_byte(w & 0xff);\n\t\tzip_put_byte(w >>> 8);\n\t}\n}\n\n/* ==========================================================================\n * Insert string s in the dictionary and set match_head to the previous head\n * of the hash chain (the most recent string with same hash key). Return\n * the previous length of the hash chain.\n * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n *    input characters and the first MIN_MATCH bytes of s are valid\n *    (except for the last MIN_MATCH-1 bytes of the input file).\n */\nfunction zip_INSERT_STRING() {\n\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT)\n\t\t^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\n\t\t& zip_HASH_MASK;\n\tzip_hash_head = zip_head1(zip_ins_h);\n\tzip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\n\tzip_head2(zip_ins_h, zip_strstart);\n}\n\n/* Send a code of the given tree. c and tree must not have side effects */\nfunction zip_SEND_CODE(c, tree) {\n\tzip_send_bits(tree[c].fc, tree[c].dl);\n}\n\n/* Mapping from a distance to a distance code. dist is the distance - 1 and\n * must not have side effects. dist_code[256] and dist_code[257] are never\n * used.\n */\nfunction zip_D_CODE(dist) {\n\treturn (dist < 256 ? zip_dist_code[dist]\n\t\t: zip_dist_code[256 + (dist >> 7)]) & 0xff;\n}\n\n/* ==========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction zip_SMALLER(tree, n, m) {\n\treturn tree[n].fc < tree[m].fc ||\n\t\t(tree[n].fc === tree[m].fc && zip_depth[n] <= zip_depth[m]);\n}\n\n/* ==========================================================================\n * read string data\n */\nfunction zip_read_buff(buff, offset, n) {\n\tvar i;\n\tfor (i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\n\t\tbuff[offset + i] =\n\t\t\tzip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\n\treturn i;\n}\n\n/* ==========================================================================\n * Initialize the \"longest match\" routines for a new file\n */\nfunction zip_lm_init() {\n\tvar j;\n\n\t/* Initialize the hash table. */\n\tfor (j = 0; j < zip_HASH_SIZE; j++)\n\t\t//\tzip_head2(j, zip_NIL);\n\t\tzip_prev[zip_WSIZE + j] = 0;\n\t/* prev will be initialized on the fly */\n\n    /* Set the default configuration parameters:\n     */\n\tzip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\n\tzip_good_match = zip_configuration_table[zip_compr_level].good_length;\n\tif (!zip_FULL_SEARCH)\n\t\tzip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\n\tzip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\n\n\tzip_strstart = 0;\n\tzip_block_start = 0;\n\n\tzip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\n\tif (zip_lookahead <= 0) {\n\t\tzip_eofile = true;\n\t\tzip_lookahead = 0;\n\t\treturn;\n\t}\n\tzip_eofile = false;\n    /* Make sure that we always have enough lookahead. This is important\n     * if input comes from a device such as a tty.\n     */\n\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t\tzip_fill_window();\n\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n     * not important since only literal bytes will be emitted.\n     */\n\tzip_ins_h = 0;\n\tfor (j = 0; j < zip_MIN_MATCH - 1; j++) {\n\t\t//      UPDATE_HASH(ins_h, window[j]);\n\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\n\t}\n}\n\n/* ==========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n */\nfunction zip_longest_match(cur_match) {\n\tvar chain_length = zip_max_chain_length; // max hash chain length\n\tvar scanp = zip_strstart; // current string\n\tvar matchp;\t\t// matched string\n\tvar len;\t\t// length of current match\n\tvar best_len = zip_prev_length;\t// best match length so far\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n\tvar limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\n\n\tvar strendp = zip_strstart + zip_MAX_MATCH;\n\tvar scan_end1 = zip_window[scanp + best_len - 1];\n\tvar scan_end = zip_window[scanp + best_len];\n\n\t/* Do not waste too much time if we already have a good match: */\n\tif (zip_prev_length >= zip_good_match)\n\t\tchain_length >>= 2;\n\n\t//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n\tdo {\n\t\t//    Assert(cur_match < encoder->strstart, \"no future\");\n\t\tmatchp = cur_match;\n\n\t\t/* Skip to next match if the match length cannot increase\n\t\t\t* or if the match length is less than 2:\n\t\t*/\n\t\tif (zip_window[matchp + best_len] !== scan_end ||\n\t\t\tzip_window[matchp + best_len - 1] !== scan_end1 ||\n\t\t\tzip_window[matchp] !== zip_window[scanp] ||\n\t\t\tzip_window[++matchp] !== zip_window[scanp + 1]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* The check at best_len-1 can be removed because it will be made\n\t\t\t * again later. (This heuristic is not always a win.)\n\t\t\t * It is not necessary to compare scan[2] and match[2] since they\n\t\t\t * are always equal when the other bytes match, given that\n\t\t\t * the hash keys are equal and that HASH_BITS >= 8.\n\t\t\t */\n\t\tscanp += 2;\n\t\tmatchp++;\n\n\t\t/* We check for insufficient lookahead only every 8th comparison;\n\t\t\t * the 256th check will be made at strstart+258.\n\t\t\t */\n\t\tdo {\n\t\t} while (zip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\tzip_window[++scanp] === zip_window[++matchp] &&\n\t\t\tscanp < strendp);\n\n\t\tlen = zip_MAX_MATCH - (strendp - scanp);\n\t\tscanp = strendp - zip_MAX_MATCH;\n\n\t\tif (len > best_len) {\n\t\t\tzip_match_start = cur_match;\n\t\t\tbest_len = len;\n\t\t\tif (zip_FULL_SEARCH) {\n\t\t\t\tif (len >= zip_MAX_MATCH) break;\n\t\t\t} else {\n\t\t\t\tif (len >= zip_nice_match) break;\n\t\t\t}\n\n\t\t\tscan_end1 = zip_window[scanp + best_len - 1];\n\t\t\tscan_end = zip_window[scanp + best_len];\n\t\t}\n\t} while ((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\n\t\t&& --chain_length !== 0);\n\n\treturn best_len;\n}\n\n/* ==========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead, and sets eofile if end of input file.\n * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n * OUT assertions: at least one byte has been read, or eofile is set;\n *    file reads are performed for at least two bytes (required for the\n *    translate_eol option).\n */\nfunction zip_fill_window() {\n\tvar n, m;\n\n\t// Amount of free space at the end of the window.\n\tvar more = zip_window_size - zip_lookahead - zip_strstart;\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n\tif (more === -1) {\n\t\t/* Very unlikely, but possible on 16 bit machine if strstart === 0\n\t\t\t * and lookahead === 1 (input done one byte at time)\n\t\t\t */\n\t\tmore--;\n\t} else if (zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\n\t\t/* By the IN assertion, the window is not empty so we can't confuse\n\t\t\t * more === 0 with more === 64K on a 16 bit machine.\n\t\t\t */\n\t\t//\tAssert(window_size === (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n\t\t//\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\n\t\tfor (n = 0; n < zip_WSIZE; n++)\n\t\t\tzip_window[n] = zip_window[n + zip_WSIZE];\n\n\t\tzip_match_start -= zip_WSIZE;\n\t\tzip_strstart -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\n\t\tzip_block_start -= zip_WSIZE;\n\n\t\tfor (n = 0; n < zip_HASH_SIZE; n++) {\n\t\t\tm = zip_head1(n);\n\t\t\tzip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n\t\t}\n\t\tfor (n = 0; n < zip_WSIZE; n++) {\n\t\t\t/* If n is not on any hash chain, prev[n] is garbage but\n\t\t\t * its value will never be used.\n\t\t\t */\n\t\t\tm = zip_prev[n];\n\t\t\tzip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n\t\t}\n\t\tmore += zip_WSIZE;\n\t}\n\t// At this point, more >= 2\n\tif (!zip_eofile) {\n\t\tn = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\n\t\tif (n <= 0)\n\t\t\tzip_eofile = true;\n\t\telse\n\t\t\tzip_lookahead += n;\n\t}\n}\n\n/* ==========================================================================\n * Processes a new input file and return its compressed length. This\n * function does not perform lazy evaluationof matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction zip_deflate_fast() {\n\twhile (zip_lookahead !== 0 && zip_qhead === null) {\n\t\tvar flush; // set if current block must be flushed\n\n\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t */\n\t\tzip_INSERT_STRING();\n\n\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t * At this point we have always match_length < MIN_MATCH\n\t\t */\n\t\tif (zip_hash_head !== zip_NIL &&\n\t\t\tzip_strstart - zip_hash_head <= zip_MAX_DIST) {\n\t\t\t/* To simplify the code, we prevent matches with the string\n\t\t\t * of window index 0 (in particular we have to avoid a match\n\t\t\t * of the string with itself at the start of the input file).\n\t\t\t */\n\t\t\tzip_match_length = zip_longest_match(zip_hash_head);\n\t\t\t/* longest_match() sets match_start */\n\t\t\tif (zip_match_length > zip_lookahead)\n\t\t\t\tzip_match_length = zip_lookahead;\n\t\t}\n\t\tif (zip_match_length >= zip_MIN_MATCH) {\n\t\t\t//\t    check_match(strstart, match_start, match_length);\n\n\t\t\tflush = zip_ct_tally(zip_strstart - zip_match_start,\n\t\t\t\tzip_match_length - zip_MIN_MATCH);\n\t\t\tzip_lookahead -= zip_match_length;\n\n\t\t\t/* Insert new strings in the hash table only if the match length\n\t\t\t * is not too large. This saves time but degrades compression.\n\t\t\t */\n\t\t\tif (zip_match_length <= zip_max_lazy_match) {\n\t\t\t\tzip_match_length--; // string at strstart already in hash table\n\t\t\t\tdo {\n\t\t\t\t\tzip_strstart++;\n\t\t\t\t\tzip_INSERT_STRING();\n\t\t\t\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t\t\t\t * these bytes are garbage, but it does not matter since\n\t\t\t\t\t * the next lookahead bytes will be emitted as literals.\n\t\t\t\t\t */\n\t\t\t\t} while (--zip_match_length !== 0);\n\t\t\t\tzip_strstart++;\n\t\t\t} else {\n\t\t\t\tzip_strstart += zip_match_length;\n\t\t\t\tzip_match_length = 0;\n\t\t\t\tzip_ins_h = zip_window[zip_strstart] & 0xff;\n\t\t\t\t//\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\n\t\t\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\n\n\t\t\t\t//#if MIN_MATCH !== 3\n\t\t\t\t//\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n\t\t\t\t//#endif\n\n\t\t\t}\n\t\t} else {\n\t\t\t/* No match, output a literal byte */\n\t\t\tflush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\n\t\t\tzip_lookahead--;\n\t\t\tzip_strstart++;\n\t\t}\n\t\tif (flush) {\n\t\t\tzip_flush_block(0);\n\t\t\tzip_block_start = zip_strstart;\n\t\t}\n\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t * string following the next match.\n\t\t */\n\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t\t\tzip_fill_window();\n\t}\n}\n\nfunction zip_deflate_better() {\n\t/* Process the input block. */\n\twhile (zip_lookahead !== 0 && zip_qhead === null) {\n\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t */\n\t\tzip_INSERT_STRING();\n\n\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t */\n\t\tzip_prev_length = zip_match_length;\n\t\tzip_prev_match = zip_match_start;\n\t\tzip_match_length = zip_MIN_MATCH - 1;\n\n\t\tif (zip_hash_head !== zip_NIL &&\n\t\t\tzip_prev_length < zip_max_lazy_match &&\n\t\t\tzip_strstart - zip_hash_head <= zip_MAX_DIST) {\n\t\t\t/* To simplify the code, we prevent matches with the string\n\t\t\t * of window index 0 (in particular we have to avoid a match\n\t\t\t * of the string with itself at the start of the input file).\n\t\t\t */\n\t\t\tzip_match_length = zip_longest_match(zip_hash_head);\n\t\t\t/* longest_match() sets match_start */\n\t\t\tif (zip_match_length > zip_lookahead)\n\t\t\t\tzip_match_length = zip_lookahead;\n\n\t\t\t/* Ignore a length 3 match if it is too distant: */\n\t\t\tif (zip_match_length === zip_MIN_MATCH &&\n\t\t\t\tzip_strstart - zip_match_start > zip_TOO_FAR) {\n\t\t\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t\t * but we will ignore the current match anyway.\n\t\t\t\t */\n\t\t\t\tzip_match_length--;\n\t\t\t}\n\t\t}\n\t\t/* If there was a match at the previous step and the current\n\t\t * match is not better, output the previous match:\n\t\t */\n\t\tif (zip_prev_length >= zip_MIN_MATCH &&\n\t\t\tzip_match_length <= zip_prev_length) {\n\t\t\tvar flush; // set if current block must be flushed\n\n\t\t\t//\t    check_match(strstart - 1, prev_match, prev_length);\n\t\t\tflush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\n\t\t\t\tzip_prev_length - zip_MIN_MATCH);\n\n\t\t\t/* Insert in hash table all strings up to the end of the match.\n\t\t\t * strstart-1 and strstart are already inserted.\n\t\t\t */\n\t\t\tzip_lookahead -= zip_prev_length - 1;\n\t\t\tzip_prev_length -= 2;\n\t\t\tdo {\n\t\t\t\tzip_strstart++;\n\t\t\t\tzip_INSERT_STRING();\n\t\t\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t\t\t * these bytes are garbage, but it does not matter since the\n\t\t\t\t * next lookahead bytes will always be emitted as literals.\n\t\t\t\t */\n\t\t\t} while (--zip_prev_length !== 0);\n\t\t\tzip_match_available = 0;\n\t\t\tzip_match_length = zip_MIN_MATCH - 1;\n\t\t\tzip_strstart++;\n\t\t\tif (flush) {\n\t\t\t\tzip_flush_block(0);\n\t\t\t\tzip_block_start = zip_strstart;\n\t\t\t}\n\t\t} else if (zip_match_available !== 0) {\n\t\t\t/* If there was no match at the previous position, output a\n\t\t\t * single literal. If there was a match but the current match\n\t\t\t * is longer, truncate the previous match to a single literal.\n\t\t\t */\n\t\t\tif (zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\n\t\t\t\tzip_flush_block(0);\n\t\t\t\tzip_block_start = zip_strstart;\n\t\t\t}\n\t\t\tzip_strstart++;\n\t\t\tzip_lookahead--;\n\t\t} else {\n\t\t\t/* There is no previous match to compare with, wait for\n\t\t\t * the next step to decide.\n\t\t\t */\n\t\t\tzip_match_available = 1;\n\t\t\tzip_strstart++;\n\t\t\tzip_lookahead--;\n\t\t}\n\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t * string following the next match.\n\t\t */\n\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t\t\tzip_fill_window();\n\t}\n}\n\nfunction zip_init_deflate() {\n\tif (zip_eofile)\n\t\treturn;\n\tzip_bi_buf = 0;\n\tzip_bi_valid = 0;\n\tzip_ct_init();\n\tzip_lm_init();\n\n\tzip_qhead = null;\n\tzip_outcnt = 0;\n\tzip_outoff = 0;\n\n\tif (zip_compr_level <= 3) {\n\t\tzip_prev_length = zip_MIN_MATCH - 1;\n\t\tzip_match_length = 0;\n\t}\n\telse {\n\t\tzip_match_length = zip_MIN_MATCH - 1;\n\t\tzip_match_available = 0;\n\t}\n\n\tzip_complete = false;\n}\n\n/* ==========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction zip_deflate_internal(buff, off, buff_size) {\n\tvar n;\n\n\tif (!zip_initflag) {\n\t\tzip_init_deflate();\n\t\tzip_initflag = true;\n\t\tif (zip_lookahead === 0) { // empty\n\t\t\tzip_complete = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((n = zip_qcopy(buff, off, buff_size)) === buff_size)\n\t\treturn buff_size;\n\n\tif (zip_complete)\n\t\treturn n;\n\n\tif (zip_compr_level <= 3) // optimized for speed\n\t\tzip_deflate_fast();\n\telse\n\t\tzip_deflate_better();\n\tif (zip_lookahead === 0) {\n\t\tif (zip_match_available !== 0)\n\t\t\tzip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\n\t\tzip_flush_block(1);\n\t\tzip_complete = true;\n\t}\n\treturn n + zip_qcopy(buff, n + off, buff_size - n);\n}\n\nfunction zip_qcopy(buff, off, buff_size) {\n\tvar n, i, j;\n\n\tn = 0;\n\twhile (zip_qhead !== null && n < buff_size) {\n\t\ti = buff_size - n;\n\t\tif (i > zip_qhead.len)\n\t\t\ti = zip_qhead.len;\n\t\t//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n\t\tfor (j = 0; j < i; j++)\n\t\t\tbuff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\n\n\t\tzip_qhead.off += i;\n\t\tzip_qhead.len -= i;\n\t\tn += i;\n\t\tif (zip_qhead.len === 0) {\n\t\t\tvar p;\n\t\t\tp = zip_qhead;\n\t\t\tzip_qhead = zip_qhead.next;\n\t\t\tzip_reuse_queue(p);\n\t\t}\n\t}\n\n\tif (n === buff_size)\n\t\treturn n;\n\n\tif (zip_outoff < zip_outcnt) {\n\t\ti = buff_size - n;\n\t\tif (i > zip_outcnt - zip_outoff)\n\t\t\ti = zip_outcnt - zip_outoff;\n\t\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\n\t\tfor (j = 0; j < i; j++)\n\t\t\tbuff[off + n + j] = zip_outbuf[zip_outoff + j];\n\t\tzip_outoff += i;\n\t\tn += i;\n\t\tif (zip_outcnt === zip_outoff)\n\t\t\tzip_outcnt = zip_outoff = 0;\n\t}\n\treturn n;\n}\n\n/* ==========================================================================\n * Allocate the match buffer, initialize the various tables and save the\n * location of the internal file attribute (ascii/binary) and method\n * (DEFLATE/STORE).\n */\nfunction zip_ct_init() {\n\tvar n;\t// iterates over tree elements\n\tvar bits;\t// bit counter\n\tvar length;\t// length value\n\tvar code;\t// code value\n\tvar dist;\t// distance index\n\n\tif (zip_static_dtree[0].dl !== 0) return; // ct_init already called\n\n\tzip_l_desc.dyn_tree = zip_dyn_ltree;\n\tzip_l_desc.static_tree = zip_static_ltree;\n\tzip_l_desc.extra_bits = zip_extra_lbits;\n\tzip_l_desc.extra_base = zip_LITERALS + 1;\n\tzip_l_desc.elems = zip_L_CODES;\n\tzip_l_desc.max_length = zip_MAX_BITS;\n\tzip_l_desc.max_code = 0;\n\n\tzip_d_desc.dyn_tree = zip_dyn_dtree;\n\tzip_d_desc.static_tree = zip_static_dtree;\n\tzip_d_desc.extra_bits = zip_extra_dbits;\n\tzip_d_desc.extra_base = 0;\n\tzip_d_desc.elems = zip_D_CODES;\n\tzip_d_desc.max_length = zip_MAX_BITS;\n\tzip_d_desc.max_code = 0;\n\n\tzip_bl_desc.dyn_tree = zip_bl_tree;\n\tzip_bl_desc.static_tree = null;\n\tzip_bl_desc.extra_bits = zip_extra_blbits;\n\tzip_bl_desc.extra_base = 0;\n\tzip_bl_desc.elems = zip_BL_CODES;\n\tzip_bl_desc.max_length = zip_MAX_BL_BITS;\n\tzip_bl_desc.max_code = 0;\n\n\t// Initialize the mapping length (0..255) -> length code (0..28)\n\tlength = 0;\n\tfor (code = 0; code < zip_LENGTH_CODES - 1; code++) {\n\t\tzip_base_length[code] = length;\n\t\tfor (n = 0; n < (1 << zip_extra_lbits[code]); n++)\n\t\t\tzip_length_code[length++] = code;\n\t}\n\t// Assert (length === 256, \"ct_init: length !== 256\");\n\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n\tzip_length_code[length - 1] = code;\n\n\t/* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\tdist = 0;\n\tfor (code = 0; code < 16; code++) {\n\t\tzip_base_dist[code] = dist;\n\t\tfor (n = 0; n < (1 << zip_extra_dbits[code]); n++) {\n\t\t\tzip_dist_code[dist++] = code;\n\t\t}\n\t}\n\t// Assert (dist === 256, \"ct_init: dist !== 256\");\n\tdist >>= 7; // from now on, all distances are divided by 128\n\tfor (; code < zip_D_CODES; code++) {\n\t\tzip_base_dist[code] = dist << 7;\n\t\tfor (n = 0; n < (1 << (zip_extra_dbits[code] - 7)); n++)\n\t\t\tzip_dist_code[256 + dist++] = code;\n\t}\n\t// Assert (dist === 256, \"ct_init: 256+dist !== 512\");\n\n\t// Construct the codes of the static literal tree\n\tfor (bits = 0; bits <= zip_MAX_BITS; bits++)\n\t\tzip_bl_count[bits] = 0;\n\tn = 0;\n\twhile (n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n\twhile (n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\n\twhile (n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\n\twhile (n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n\tzip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\n\n\t/* The static distance tree is trivial: */\n\tfor (n = 0; n < zip_D_CODES; n++) {\n\t\tzip_static_dtree[n].dl = 5;\n\t\tzip_static_dtree[n].fc = zip_bi_reverse(n, 5);\n\t}\n\n\t// Initialize the first block of the first file:\n\tzip_init_block();\n}\n\n/* ==========================================================================\n * Initialize a new block.\n */\nfunction zip_init_block() {\n\tvar n; // iterates over tree elements\n\n\t// Initialize the trees.\n\tfor (n = 0; n < zip_L_CODES; n++) zip_dyn_ltree[n].fc = 0;\n\tfor (n = 0; n < zip_D_CODES; n++) zip_dyn_dtree[n].fc = 0;\n\tfor (n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\n\n\tzip_dyn_ltree[zip_END_BLOCK].fc = 1;\n\tzip_opt_len = zip_static_len = 0;\n\tzip_last_lit = zip_last_dist = zip_last_flags = 0;\n\tzip_flags = 0;\n\tzip_flag_bit = 1;\n}\n\n/* ==========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction zip_pqdownheap(\n\ttree,\t// the tree to restore\n\tk) {\t// node to move down\n\tvar v = zip_heap[k];\n\tvar j = k << 1;\t// left son of k\n\n\twhile (j <= zip_heap_len) {\n\t\t// Set j to the smallest of the two sons:\n\t\tif (j < zip_heap_len &&\n\t\t\tzip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\n\t\t\tj++;\n\n\t\t// Exit if v is smaller than both sons\n\t\tif (zip_SMALLER(tree, v, zip_heap[j]))\n\t\t\tbreak;\n\n\t\t// Exchange v with the smallest son\n\t\tzip_heap[k] = zip_heap[j];\n\t\tk = j;\n\n\t\t// And continue down the tree, setting j to the left son of k\n\t\tj <<= 1;\n\t}\n\tzip_heap[k] = v;\n}\n\n/* ==========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction zip_gen_bitlen(desc) { // the tree descriptor\n\tvar tree = desc.dyn_tree;\n\tvar extra = desc.extra_bits;\n\tvar base = desc.extra_base;\n\tvar max_code = desc.max_code;\n\tvar max_length = desc.max_length;\n\tvar stree = desc.static_tree;\n\tvar h;\t\t// heap index\n\tvar n, m;\t\t// iterate over the tree elements\n\tvar bits;\t\t// bit length\n\tvar xbits;\t\t// extra bits\n\tvar f;\t\t// frequency\n\tvar overflow = 0;\t// number of elements with bit length too large\n\n\tfor (bits = 0; bits <= zip_MAX_BITS; bits++)\n\t\tzip_bl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n\ttree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\n\n\tfor (h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\n\t\tn = zip_heap[h];\n\t\tbits = tree[tree[n].dl].dl + 1;\n\t\tif (bits > max_length) {\n\t\t\tbits = max_length;\n\t\t\toverflow++;\n\t\t}\n\t\ttree[n].dl = bits;\n\t\t// We overwrite tree[n].dl which is no longer needed\n\n\t\tif (n > max_code)\n\t\t\tcontinue; // not a leaf node\n\n\t\tzip_bl_count[bits]++;\n\t\txbits = 0;\n\t\tif (n >= base)\n\t\t\txbits = extra[n - base];\n\t\tf = tree[n].fc;\n\t\tzip_opt_len += f * (bits + xbits);\n\t\tif (stree !== null)\n\t\t\tzip_static_len += f * (stree[n].dl + xbits);\n\t}\n\tif (overflow === 0)\n\t\treturn;\n\n\t// This happens for example on obj2 and pic of the Calgary corpus\n\n\t// Find the first bit length which could increase:\n\tdo {\n\t\tbits = max_length - 1;\n\t\twhile (zip_bl_count[bits] === 0)\n\t\t\tbits--;\n\t\tzip_bl_count[bits]--;\t\t// move one leaf down the tree\n\t\tzip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\n\t\tzip_bl_count[max_length]--;\n\t\t/* The brother of the overflow item also moves one step up,\n\t\t * but this does not affect bl_count[max_length]\n\t\t */\n\t\toverflow -= 2;\n\t} while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n\tfor (bits = max_length; bits !== 0; bits--) {\n\t\tn = zip_bl_count[bits];\n\t\twhile (n !== 0) {\n\t\t\tm = zip_heap[--h];\n\t\t\tif (m > max_code)\n\t\t\t\tcontinue;\n\t\t\tif (tree[m].dl !== bits) {\n\t\t\t\tzip_opt_len += (bits - tree[m].dl) * tree[m].fc;\n\t\t\t\ttree[m].fc = bits;\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n}\n\n/* ==========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction zip_gen_codes(tree,\t// the tree to decorate\n\tmax_code) {\t// largest code with non zero frequency\n\tvar next_code = new Array(zip_MAX_BITS + 1); // next code value for each bit length\n\tvar code = 0;\t\t// running code value\n\tvar bits;\t\t\t// bit index\n\tvar n;\t\t\t// code index\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n\tfor (bits = 1; bits <= zip_MAX_BITS; bits++) {\n\t\tcode = ((code + zip_bl_count[bits - 1]) << 1);\n\t\tnext_code[bits] = code;\n\t}\n\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n\t//    Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1,\n\t//\t    \"inconsistent bit counts\");\n\t//    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tvar len = tree[n].dl;\n\t\tif (len === 0)\n\t\t\tcontinue;\n\t\t// Now reverse the bits\n\t\ttree[n].fc = zip_bi_reverse(next_code[len]++, len);\n\n\t\t//      Tracec(tree !== static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n\t\t//\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n\t}\n}\n\n/* ==========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction zip_build_tree(desc) { // the tree descriptor\n\tvar tree = desc.dyn_tree;\n\tvar stree = desc.static_tree;\n\tvar elems = desc.elems;\n\tvar n, m;\t\t// iterate over heap elements\n\tvar max_code = -1;\t// largest code with non zero frequency\n\tvar node = elems;\t// next internal node of the tree\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n\tzip_heap_len = 0;\n\tzip_heap_max = zip_HEAP_SIZE;\n\n\tfor (n = 0; n < elems; n++) {\n\t\tif (tree[n].fc !== 0) {\n\t\t\tzip_heap[++zip_heap_len] = max_code = n;\n\t\t\tzip_depth[n] = 0;\n\t\t} else\n\t\t\ttree[n].dl = 0;\n\t}\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n\twhile (zip_heap_len < 2) {\n\t\tvar xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\n\t\ttree[xnew].fc = 1;\n\t\tzip_depth[xnew] = 0;\n\t\tzip_opt_len--;\n\t\tif (stree !== null)\n\t\t\tzip_static_len -= stree[xnew].dl;\n\t\t// new is 0 or 1 so it does not have extra bits\n\t}\n\tdesc.max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n\tfor (n = zip_heap_len >> 1; n >= 1; n--)\n\t\tzip_pqdownheap(tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n\tdo {\n\t\tn = zip_heap[zip_SMALLEST];\n\t\tzip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\n\t\tzip_pqdownheap(tree, zip_SMALLEST);\n\n\t\tm = zip_heap[zip_SMALLEST];  // m = node of next least frequency\n\n\t\t// keep the nodes sorted by frequency\n\t\tzip_heap[--zip_heap_max] = n;\n\t\tzip_heap[--zip_heap_max] = m;\n\n\t\t// Create a new node father of n and m\n\t\ttree[node].fc = tree[n].fc + tree[m].fc;\n\t\t//\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n\t\tif (zip_depth[n] > zip_depth[m] + 1)\n\t\t\tzip_depth[node] = zip_depth[n];\n\t\telse\n\t\t\tzip_depth[node] = zip_depth[m] + 1;\n\t\ttree[n].dl = tree[m].dl = node;\n\n\t\t// and insert the new node in the heap\n\t\tzip_heap[zip_SMALLEST] = node++;\n\t\tzip_pqdownheap(tree, zip_SMALLEST);\n\n\t} while (zip_heap_len >= 2);\n\n\tzip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n\tzip_gen_bitlen(desc);\n\n\t// The field len is now set, we can generate the bit codes\n\tzip_gen_codes(tree, max_code);\n}\n\n/* ==========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree. Updates opt_len to take into account the repeat\n * counts. (The contribution of the bit length codes will be added later\n * during the construction of bl_tree.)\n */\nfunction zip_scan_tree(tree,// the tree to be scanned\n\tmax_code) {  // and its largest code of non zero frequency\n\tvar n;\t\t\t// iterates over all tree elements\n\tvar prevlen = -1;\t\t// last emitted length\n\tvar curlen;\t\t\t// length of current code\n\tvar nextlen = tree[0].dl;\t// length of next code\n\tvar count = 0;\t\t// repeat count of the current code\n\tvar max_count = 7;\t\t// max repeat count\n\tvar min_count = 4;\t\t// min repeat count\n\n\tif (nextlen === 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t}\n\ttree[max_code + 1].dl = 0xffff; // guard\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[n + 1].dl;\n\t\tif (++count < max_count && curlen === nextlen)\n\t\t\tcontinue;\n\t\telse if (count < min_count)\n\t\t\tzip_bl_tree[curlen].fc += count;\n\t\telse if (curlen !== 0) {\n\t\t\tif (curlen !== prevlen)\n\t\t\t\tzip_bl_tree[curlen].fc++;\n\t\t\tzip_bl_tree[zip_REP_3_6].fc++;\n\t\t} else if (count <= 10)\n\t\t\tzip_bl_tree[zip_REPZ_3_10].fc++;\n\t\telse\n\t\t\tzip_bl_tree[zip_REPZ_11_138].fc++;\n\t\tcount = 0; prevlen = curlen;\n\t\tif (nextlen === 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t} else if (curlen === nextlen) {\n\t\t\tmax_count = 6;\n\t\t\tmin_count = 3;\n\t\t} else {\n\t\t\tmax_count = 7;\n\t\t\tmin_count = 4;\n\t\t}\n\t}\n}\n\n/* ==========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction zip_send_tree(tree, // the tree to be scanned\n\tmax_code) { // and its largest code of non zero frequency\n\tvar n;\t\t\t// iterates over all tree elements\n\tvar prevlen = -1;\t\t// last emitted length\n\tvar curlen;\t\t\t// length of current code\n\tvar nextlen = tree[0].dl;\t// length of next code\n\tvar count = 0;\t\t// repeat count of the current code\n\tvar max_count = 7;\t\t// max repeat count\n\tvar min_count = 4;\t\t// min repeat count\n\n\t/* tree[max_code+1].dl = -1; */  /* guard already set */\n\tif (nextlen === 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t}\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[n + 1].dl;\n\t\tif (++count < max_count && curlen === nextlen) {\n\t\t\tcontinue;\n\t\t} else if (count < min_count) {\n\t\t\tdo { zip_SEND_CODE(curlen, zip_bl_tree); } while (--count !== 0);\n\t\t} else if (curlen !== 0) {\n\t\t\tif (curlen !== prevlen) {\n\t\t\t\tzip_SEND_CODE(curlen, zip_bl_tree);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\t// Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t\t\tzip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\n\t\t\tzip_send_bits(count - 3, 2);\n\t\t} else if (count <= 10) {\n\t\t\tzip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\n\t\t\tzip_send_bits(count - 3, 3);\n\t\t} else {\n\t\t\tzip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\n\t\t\tzip_send_bits(count - 11, 7);\n\t\t}\n\t\tcount = 0;\n\t\tprevlen = curlen;\n\t\tif (nextlen === 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t} else if (curlen === nextlen) {\n\t\t\tmax_count = 6;\n\t\t\tmin_count = 3;\n\t\t} else {\n\t\t\tmax_count = 7;\n\t\t\tmin_count = 4;\n\t\t}\n\t}\n}\n\n/* ==========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction zip_build_bl_tree() {\n\tvar max_blindex;  // index of last bit length code of non zero freq\n\n\t// Determine the bit length frequencies for literal and distance trees\n\tzip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\n\tzip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\n\n\t// Build the bit length tree:\n\tzip_build_tree(zip_bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n\tfor (max_blindex = zip_BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t\tif (zip_bl_tree[zip_bl_order[max_blindex]].dl !== 0) break;\n\t}\n\t/* Update opt_len to include the bit length tree and counts */\n\tzip_opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t//    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n\t//\t    encoder->opt_len, encoder->static_len));\n\n\treturn max_blindex;\n}\n\n/* ==========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\n\tvar rank; // index in bl_order\n\n\t//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n\t//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n\t//\t    \"too many codes\");\n\t//    Tracev((stderr, \"\\nbl counts: \"));\n\tzip_send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\tzip_send_bits(dcodes - 1, 5);\n\tzip_send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n\tfor (rank = 0; rank < blcodes; rank++) {\n\t\t//      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\t\tzip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\n\t}\n\n\t// send the literal tree\n\tzip_send_tree(zip_dyn_ltree, lcodes - 1);\n\n\t// send the distance tree\n\tzip_send_tree(zip_dyn_dtree, dcodes - 1);\n}\n\n/* ==========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction zip_flush_block(eof) { // true if this is the last block for a file\n\tvar opt_lenb, static_lenb; // opt_len and static_len in bytes\n\tvar max_blindex;\t// index of last bit length code of non zero freq\n\tvar stored_len;\t// length of input block\n\n\tstored_len = zip_strstart - zip_block_start;\n\tzip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\n\n\t// Construct the literal and distance trees\n\tzip_build_tree(zip_l_desc);\n\t//    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n\t//\t    encoder->opt_len, encoder->static_len));\n\n\tzip_build_tree(zip_d_desc);\n\t//    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n\t//\t    encoder->opt_len, encoder->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n\tmax_blindex = zip_build_bl_tree();\n\n\t// Determine the best encoding. Compute first the block length in bytes\n\topt_lenb = (zip_opt_len + 3 + 7) >> 3;\n\tstatic_lenb = (zip_static_len + 3 + 7) >> 3;\n\n\t//    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n\t//\t   opt_lenb, encoder->opt_len,\n\t//\t   static_lenb, encoder->static_len, stored_len,\n\t//\t   encoder->last_lit, encoder->last_dist));\n\n\tif (static_lenb <= opt_lenb)\n\t\topt_lenb = static_lenb;\n\tif (stored_len + 4 <= opt_lenb // 4: two words for the lengths\n\t\t&& zip_block_start >= 0) {\n\t\tvar i;\n\n\t\t/* The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t\t * the last block flush, because compression would have been\n\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t * transform a block into a stored block.\n\t\t */\n\t\tzip_send_bits((zip_STORED_BLOCK << 1) + eof, 3);  /* send block type */\n\t\tzip_bi_windup();\t\t /* align on byte boundary */\n\t\tzip_put_short(stored_len);\n\t\tzip_put_short(~stored_len);\n\n\t\t// copy block\n\t\t/*\n\t\t\t  p = &window[block_start];\n\t\t\t  for(i = 0; i < stored_len; i++)\n\t\t\tput_byte(p[i]);\n\t\t*/\n\t\tfor (i = 0; i < stored_len; i++)\n\t\t\tzip_put_byte(zip_window[zip_block_start + i]);\n\n\t} else if (static_lenb === opt_lenb) {\n\t\tzip_send_bits((zip_STATIC_TREES << 1) + eof, 3);\n\t\tzip_compress_block(zip_static_ltree, zip_static_dtree);\n\t} else {\n\t\tzip_send_bits((zip_DYN_TREES << 1) + eof, 3);\n\t\tzip_send_all_trees(zip_l_desc.max_code + 1,\n\t\t\tzip_d_desc.max_code + 1,\n\t\t\tmax_blindex + 1);\n\t\tzip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\n\t}\n\n\tzip_init_block();\n\n\tif (eof !== 0)\n\t\tzip_bi_windup();\n}\n\n/* ==========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction zip_ct_tally(\n\tdist, // distance of matched string\n\tlc) { // match length-MIN_MATCH or unmatched char (if dist==0)\n\tzip_l_buf[zip_last_lit++] = lc;\n\tif (dist === 0) {\n\t\t// lc is the unmatched char\n\t\tzip_dyn_ltree[lc].fc++;\n\t} else {\n\t\t// Here, lc is the match length - MIN_MATCH\n\t\tdist--;\t\t    // dist = match distance - 1\n\t\t//      Assert((ush)dist < (ush)MAX_DIST &&\n\t\t//\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n\t\t//\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n\t\tzip_dyn_ltree[zip_length_code[lc] + zip_LITERALS + 1].fc++;\n\t\tzip_dyn_dtree[zip_D_CODE(dist)].fc++;\n\n\t\tzip_d_buf[zip_last_dist++] = dist;\n\t\tzip_flags |= zip_flag_bit;\n\t}\n\tzip_flag_bit <<= 1;\n\n\t// Output the flags if they fill a byte\n\tif ((zip_last_lit & 7) === 0) {\n\t\tzip_flag_buf[zip_last_flags++] = zip_flags;\n\t\tzip_flags = 0;\n\t\tzip_flag_bit = 1;\n\t}\n\t// Try to guess if it is profitable to stop the current block here\n\tif (zip_compr_level > 2 && (zip_last_lit & 0xfff) === 0) {\n\t\t// Compute an upper bound for the compressed length\n\t\tvar out_length = zip_last_lit * 8;\n\t\tvar in_length = zip_strstart - zip_block_start;\n\t\tvar dcode;\n\n\t\tfor (dcode = 0; dcode < zip_D_CODES; dcode++) {\n\t\t\tout_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\n\t\t}\n\t\tout_length >>= 3;\n\t\t//      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n\t\t//\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\n\t\t//\t     100L - out_length*100L/in_length));\n\t\tif (zip_last_dist < parseInt(zip_last_lit / 2) &&\n\t\t\tout_length < parseInt(in_length / 2))\n\t\t\treturn true;\n\t}\n\treturn (zip_last_lit === zip_LIT_BUFSIZE - 1 ||\n\t\tzip_last_dist === zip_DIST_BUFSIZE);\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n}\n\n/* ==========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction zip_compress_block(\n\tltree,\t// literal tree\n\tdtree) {\t// distance tree\n\tvar dist;\t\t// distance of matched string\n\tvar lc;\t\t// match length or unmatched char (if dist === 0)\n\tvar lx = 0;\t\t// running index in l_buf\n\tvar dx = 0;\t\t// running index in d_buf\n\tvar fx = 0;\t\t// running index in flag_buf\n\tvar flag = 0;\t// current flags\n\tvar code;\t\t// the code to send\n\tvar extra;\t\t// number of extra bits to send\n\n\tif (zip_last_lit !== 0) do {\n\t\tif ((lx & 7) === 0)\n\t\t\tflag = zip_flag_buf[fx++];\n\t\tlc = zip_l_buf[lx++] & 0xff;\n\t\tif ((flag & 1) === 0) {\n\t\t\tzip_SEND_CODE(lc, ltree); /* send a literal byte */\n\t\t\t//\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t\t} else {\n\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\tcode = zip_length_code[lc];\n\t\t\tzip_SEND_CODE(code + zip_LITERALS + 1, ltree); // send the length code\n\t\t\textra = zip_extra_lbits[code];\n\t\t\tif (extra !== 0) {\n\t\t\t\tlc -= zip_base_length[code];\n\t\t\t\tzip_send_bits(lc, extra); // send the extra length bits\n\t\t\t}\n\t\t\tdist = zip_d_buf[dx++];\n\t\t\t// Here, dist is the match distance - 1\n\t\t\tcode = zip_D_CODE(dist);\n\t\t\t//\tAssert (code < D_CODES, \"bad d_code\");\n\n\t\t\tzip_SEND_CODE(code, dtree);\t  // send the distance code\n\t\t\textra = zip_extra_dbits[code];\n\t\t\tif (extra !== 0) {\n\t\t\t\tdist -= zip_base_dist[code];\n\t\t\t\tzip_send_bits(dist, extra);   // send the extra distance bits\n\t\t\t}\n\t\t} // literal or match pair ?\n\t\tflag >>= 1;\n\t} while (lx < zip_last_lit);\n\n\tzip_SEND_CODE(zip_END_BLOCK, ltree);\n}\n\n/* ==========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nvar zip_Buf_size = 16; // bit size of bi_buf\nfunction zip_send_bits(\n\tvalue,\t// value to send\n\tlength) {\t// number of bits\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     */\n\tif (zip_bi_valid > zip_Buf_size - length) {\n\t\tzip_bi_buf |= (value << zip_bi_valid);\n\t\tzip_put_short(zip_bi_buf);\n\t\tzip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\n\t\tzip_bi_valid += length - zip_Buf_size;\n\t} else {\n\t\tzip_bi_buf |= value << zip_bi_valid;\n\t\tzip_bi_valid += length;\n\t}\n}\n\n/* ==========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction zip_bi_reverse(\n\tcode,\t// the value to invert\n\tlen) {\t// its bit length\n\tvar res = 0;\n\tdo {\n\t\tres |= code & 1;\n\t\tcode >>= 1;\n\t\tres <<= 1;\n\t} while (--len > 0);\n\treturn res >> 1;\n}\n\n/* ==========================================================================\n * Write out any remaining bits in an incomplete byte.\n */\nfunction zip_bi_windup() {\n\tif (zip_bi_valid > 8) {\n\t\tzip_put_short(zip_bi_buf);\n\t} else if (zip_bi_valid > 0) {\n\t\tzip_put_byte(zip_bi_buf);\n\t}\n\tzip_bi_buf = 0;\n\tzip_bi_valid = 0;\n}\n\nfunction zip_qoutbuf() {\n\tif (zip_outcnt !== 0) {\n\t\tvar q, i;\n\t\tq = zip_new_queue();\n\t\tif (zip_qhead === null)\n\t\t\tzip_qhead = zip_qtail = q;\n\t\telse\n\t\t\tzip_qtail = zip_qtail.next = q;\n\t\tq.len = zip_outcnt - zip_outoff;\n\t\t//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\n\t\tfor (i = 0; i < q.len; i++)\n\t\t\tq.ptr[i] = zip_outbuf[zip_outoff + i];\n\t\tzip_outcnt = zip_outoff = 0;\n\t}\n}\n\nexport function codify(word) {\n\treturn new Promise(function(resolve, reject) {\n\t\tvar zip = zip_deflate(word, 9);\n\t\tresolve(encode64(zip));\n\t});\n}\n\nfunction zip_deflate(str, level) {\n\tvar out, buff;\n\tvar i, j;\n\n\tzip_deflate_data = str;\n\tzip_deflate_pos = 0;\n\tif (typeof level === \"undefined\")\n\t\tlevel = zip_DEFAULT_LEVEL;\n\tzip_deflate_start(level);\n\n\tbuff = new Array(1024);\n\tout = \"\";\n\twhile ((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\n\t\tfor (j = 0; j < i; j++)\n\t\t\tout += String.fromCharCode(buff[j]);\n\t}\n\tzip_deflate_data = null; // G.C.\n\treturn out;\n}\n\nfunction encode64(data) {\n\tvar r = \"\";\n\tfor (let i = 0; i < data.length; i += 3) {\n\t\tif (i + 2 === data.length) {\n\t\t\tr += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\n\t\t} else if (i + 1 === data.length) {\n\t\t\tr += append3bytes(data.charCodeAt(i), 0, 0);\n\t\t} else {\n\t\t\tr += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), data.charCodeAt(i + 2));\n\t\t}\n\t}\n\treturn r;\n}\n\nfunction append3bytes(b1, b2, b3) {\n\tvar c1 = b1 >> 2;\n\tvar c2 = ((b1 & 0x3) << 4) | (b2 >> 4);\n\tvar c3 = ((b2 & 0xF) << 2) | (b3 >> 6);\n\tvar c4 = b3 & 0x3F;\n\tvar r = \"\";\n\tr += encode6bit(c1 & 0x3F);\n\tr += encode6bit(c2 & 0x3F);\n\tr += encode6bit(c3 & 0x3F);\n\tr += encode6bit(c4 & 0x3F);\n\treturn r;\n}\n\nfunction encode6bit(b) {\n\tif (b < 10) {\n\t\treturn String.fromCharCode(48 + b);\n\t}\n\tb -= 10;\n\tif (b < 26) {\n\t\treturn String.fromCharCode(65 + b);\n\t}\n\tb -= 26;\n\tif (b < 26) {\n\t\treturn String.fromCharCode(97 + b);\n\t}\n\tb -= 26;\n\tif (b === 0) {\n\t\treturn '-';\n\t}\n\tif (b === 1) {\n\t\treturn '_';\n\t}\n\treturn '?';\n}","import React from 'react';\nimport uml from '../../assets/home_uml.png';\nimport { codify } from '../../assets/deflate';\n\nconst Home = () => {\n\n    function send(e) {\n        let text = document.querySelector('#text-uml').value;\n        text = unescape(encodeURIComponent(text));\n        let sendBtn = e.target;\n        sendBtn.classList.add('is-loading');\n        codify(text).then(data => {\n            document.querySelector('#img-uml').src = `https://www.plantuml.com/plantuml/img/${data}`;\n            setTimeout(()=> {\n                sendBtn.classList.remove('is-loading');\n            }, 500)\n        })\n    }\n\n    return (\n        <div className=\"container is-fluid is-flex body-container\">\n            <div className=\"text\">\n                <textarea defaultValue=\"Rebeca -> Joe : Hi\" id=\"text-uml\" spellCheck=\"false\" />\n                <button className=\"button is-action\" onClick={send}>Send</button>\n            </div>\n            <div className=\"image\">\n                <img src={uml} alt=\"uml-graph\" id=\"img-uml\" />\n            </div>\n        </div>\n    );\n}\n\nexport default Home;\n","import React from 'react';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faHashtag, faAngleRight } from '@fortawesome/free-solid-svg-icons';\nimport imgUml1 from '../../assets/ab_uml1.png';\n\nconst About = () => {\n    \n    let uml1 = `@startuml\n:Hello world;\n:This is \nthe **beggining**;\n@enduml`;\n\n    return (\n        <div className=\"container is-fluid body-container\">\n            <section className=\"usage\">\n                <div className=\"ab-title big\">\n                    <FontAwesomeIcon icon={faHashtag} />\n                    <h1 className=\"text text-b\">Usage</h1>\n                </div>\n                <h1>All you need to do is write your UML text in the box and send, then you will get your diagram. For example this text:</h1>\n                <pre>{uml1}</pre>\n                <h1>Will be transformed in this image:</h1>\n                <img src={imgUml1} alt=\"uml1\"/>\n                <h1 className=\"has-text-weight-bold\t\">To download right click and save as...</h1>\n            </section>\n            <section className=\"demo mt-1\">\n                <div className=\"ab-title big\">\n                    <FontAwesomeIcon icon={faHashtag} />\n                    <h1 className=\"text text-b\">Diagrams</h1>\n                </div>\n                <h1>This web uses the UML language from plantUML:</h1>\n                <div className=\"ab-title lit mt-1\">\n                    <FontAwesomeIcon icon={faAngleRight} />\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/sequence-diagram\">Sequence</a>\n                </div>\n                <div className=\"ab-title lit mt-1\">\n                    <FontAwesomeIcon icon={faAngleRight} />\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/activity-diagram-beta\">Activity</a>\n                </div>\n                <div className=\"ab-title lit mt-1\">\n                    <FontAwesomeIcon icon={faAngleRight} />\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/use-case-diagram\">Usecase</a>\n                </div>\n                <div className=\"ab-title lit mt-1\">\n                    <FontAwesomeIcon icon={faAngleRight} />\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/class-diagram\">Class</a>\n                </div>\n                <div className=\"ab-title lit mt-1\">\n                    <FontAwesomeIcon icon={faAngleRight} />\n                    <a className=\"text companion\" href=\"https://plantuml.com/en/\">Many more...</a>\n                </div>\n            </section>\n        </div>\n    );\n}\n\nexport default About;\n","import React from 'react';\nimport './App.scss';\nimport {\n  HashRouter as Router,\n  Route,\n  Switch\n} from 'react-router-dom';\nimport Nav from './components/Nav/Nav';\nimport Home from './components/Home/Home';\nimport About from './components/About/About';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Router>\n        <Nav />\n        \n        <Switch>\n          <Route path=\"/\" exact component={Home} />\n          <Route path=\"/about\" component={About} />\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport 'bulma/css/bulma.min.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}